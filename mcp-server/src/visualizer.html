<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Godot Project Map</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  /* Claude-inspired palette */
  --bg-primary: #1a1a1e;
  --bg-secondary: #242428;
  --bg-tertiary: #2e2e33;
  --bg-hover: #35353b;
  --bg-surface: #28282d;
  --border: #3a3a40;
  --border-light: #4a4a52;
  --text-primary: #e8e4df;
  --text-secondary: #a8a49e;
  --text-muted: #706c66;
  --accent: #d4a27f;
  --accent-light: #e4b896;
  --accent-dim: #8b6f55;

  /* GDScript syntax colors */
  --gd-keyword: #cc7832;
  --gd-func-name: #ffc66d;
  --gd-type: #6897bb;
  --gd-string: #6a8759;
  --gd-number: #6897bb;
  --gd-comment: #808080;
  --gd-var: #cc7832;
  --gd-signal: #a6e3a1;
  --gd-export: #bbb529;
  --gd-builtin: #8888c6;

  /* Edge colors */
  --edge-extends: #7aa2f7;
  --edge-preload: #d4a27f;
  --edge-signal: #a6e3a1;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  overflow: hidden;
  height: 100vh;
}

canvas { display: block; cursor: grab; }
canvas.dragging { cursor: grabbing; }

/* Search bar */
#search-bar {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 10px 18px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#search-bar input {
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 14px;
  width: 260px;
  font-family: inherit;
}

#search-bar input::placeholder { color: var(--text-muted); }
#search-bar .stats { color: var(--text-muted); font-size: 12px; white-space: nowrap; }

#search-bar svg { flex-shrink: 0; }

/* View tabs */
#view-tabs {
  position: fixed;
  top: 16px;
  left: 16px;
  z-index: 100;
  display: flex;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 4px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#view-tabs button {
  background: transparent;
  border: none;
  color: var(--text-muted);
  font-size: 13px;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}

#view-tabs button:hover { color: var(--text-secondary); background: var(--bg-hover); }
#view-tabs button.active { color: var(--text-primary); background: var(--bg-tertiary); }

/* Context menu */
#context-menu {
  position: fixed;
  z-index: 500;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px 0;
  min-width: 180px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  display: none;
}

#context-menu.visible { display: block; }

#context-menu .menu-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: background 0.1s;
}

#context-menu .menu-item:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

#context-menu .menu-item svg { flex-shrink: 0; opacity: 0.7; }

#context-menu .menu-divider {
  height: 1px;
  background: var(--border);
  margin: 6px 0;
}

/* Modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.6);
  z-index: 600;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  width: 400px;
  box-shadow: 0 16px 64px rgba(0,0,0,0.5);
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
}

.modal-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
}

.modal-body {
  padding: 20px;
}

.modal-body .form-group {
  margin-bottom: 16px;
}

.modal-body .form-group:last-child { margin-bottom: 0; }

.modal-body label {
  display: block;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 6px;
}

.modal-body input, .modal-body select {
  width: 100%;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 12px;
  font-size: 14px;
  color: var(--text-primary);
  font-family: 'SF Mono', Monaco, monospace;
}

.modal-body input:focus, .modal-body select:focus {
  outline: none;
  border-color: var(--accent);
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding: 16px 20px;
  border-top: 1px solid var(--border);
}

.modal-footer button {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  border: 1px solid var(--border);
}

.modal-footer .cancel {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}

.modal-footer .confirm {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

.modal-footer .confirm:hover { background: var(--accent-light); }

/* Legend */
#legend {
  position: fixed;
  bottom: 16px;
  left: 16px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 18px;
  font-size: 12px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

/* Zoom indicator - positioned bottom-left, offset from legend */
#zoom-indicator {
  position: fixed;
  bottom: 16px;
  left: 150px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#zoom-indicator:hover { background: var(--bg-hover); border-color: var(--border-light); }
#zoom-indicator.faded { opacity: 0.4; }
#zoom-indicator.faded:hover { opacity: 1; }
#zoom-indicator svg { flex-shrink: 0; }
#zoom-indicator .zoom-text { color: var(--text-secondary); font-weight: 500; min-width: 36px; text-align: center; }

#legend .item { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; color: var(--text-secondary); }
#legend .item:last-child { margin-bottom: 0; }
#legend .line { width: 28px; height: 2px; border-radius: 1px; }

/* Detail panel */
#detail-panel {
  position: fixed;
  top: 0;
  right: -480px;
  width: 460px;
  min-width: 300px;
  max-width: 80vw;
  height: 100vh;
  background: var(--bg-primary);
  border-left: 1px solid var(--border);
  z-index: 200;
  overflow-y: auto;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: -8px 0 32px rgba(0,0,0,0.4);
}

#detail-panel.open { right: 0; }
#detail-panel.resizing { transition: none; }

/* Horizontal resize handle for panel */
#panel-resize-handle {
  position: absolute;
  left: -4px;
  top: 0;
  width: 8px;
  height: 100%;
  cursor: col-resize;
  z-index: 201;
}
#panel-resize-handle::after {
  content: '';
  position: absolute;
  left: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 50px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.2s;
}
#panel-resize-handle:hover::after,
#detail-panel.resizing #panel-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

#detail-panel::-webkit-scrollbar { width: 6px; }
#detail-panel::-webkit-scrollbar-track { background: transparent; }
#detail-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.panel-header {
  position: sticky;
  top: 0;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 20px 24px;
  z-index: 10;
}

.panel-header h2 {
  font-size: 20px;
  font-weight: 600;
  color: var(--accent-light);
  margin-bottom: 4px;
  padding-right: 40px;
}

.panel-header .path {
  font-size: 12px;
  color: var(--text-muted);
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  word-break: break-all;
}

.close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 30px;
  height: 30px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.close-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

.panel-body { padding: 16px 24px 32px; }

.desc-block {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  padding: 10px 14px;
  background: var(--bg-secondary);
  border-radius: 8px;
  border-left: 3px solid var(--accent);
  line-height: 1.5;
}

.meta-row {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.meta-badge {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  color: var(--text-secondary);
}

.meta-badge span { color: var(--accent-light); font-weight: 600; }

/* Sections */
.section {
  margin-bottom: 16px;
}

.section .item-list {
  /* No max-height - show all items */
}

.section-resize-handle {
  position: relative;
  height: 12px;
  cursor: row-resize;
  z-index: 5;
  margin: 4px 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.section-resize-handle::after {
  content: '';
  width: 40px;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0.3;
  transition: opacity 0.2s;
}

.section-resize-handle:hover::after,
.section.resizing .section-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
}

.section-count {
  background: var(--bg-tertiary);
  color: var(--text-muted);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
}

.item-list { list-style: none; }

.item-list li {
  padding: 6px 10px;
  border-radius: 6px;
  margin-bottom: 1px;
  font-size: 13px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 6px;
  line-height: 1.4;
}

.item-list li:hover { background: var(--bg-secondary); }
.item-list li.clickable { cursor: pointer; }
.item-list li.clickable:hover { background: var(--bg-tertiary); }

/* Inline editable items */
.item-list li .item-actions {
  margin-left: auto;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  flex-shrink: 0;
}
.item-list li:hover .item-actions { opacity: 1; }
.item-list li:hover .delete { opacity: 1 !important; }
.item-actions button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  width: 22px;
  height: 22px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.item-actions button:hover { background: var(--bg-hover); color: var(--text-primary); }
.item-actions button.delete:hover { background: #3d2020; color: #f38ba8; }

/* Inline editable spans */
.editable {
  cursor: text;
  padding: 1px 4px;
  margin: -1px -4px;
  border-radius: 3px;
  transition: background 0.15s;
  min-width: 20px;
  display: inline-block;
}
.editable:hover { background: rgba(255,255,255,0.08); }
.editable:focus {
  outline: none;
  background: rgba(255,255,255,0.12);
  box-shadow: 0 0 0 1px var(--accent);
}
.editable[data-placeholder]:empty::before {
  content: attr(data-placeholder);
  color: var(--text-muted);
  opacity: 0.5;
}

/* @onready badge */
.onready-badge {
  display: inline-block;
  font-size: 9px;
  padding: 2px 5px;
  background: rgba(137, 180, 250, 0.2);
  color: #89b4fa;
  border-radius: 3px;
  margin-right: 6px;
  font-weight: 500;
  cursor: pointer;
  user-select: none;
}
.onready-badge:hover { background: rgba(137, 180, 250, 0.3); }
.onready-badge.inactive {
  background: rgba(255,255,255,0.05);
  color: var(--text-muted);
  opacity: 0.5;
}

/* Floating usage panel (to the left of detail panel) */
#usage-float-panel {
  position: fixed;
  top: 80px;
  right: 480px;
  width: 380px;
  min-width: 300px;
  min-height: 250px;
  max-height: calc(100vh - 100px);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  z-index: 150;
  display: none;
  flex-direction: column;
  overflow: hidden;
}

#usage-float-panel.visible { display: flex; }
#usage-float-panel.dragging { user-select: none; }

/* Resize handle */
#usage-float-panel .ufp-resize {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 16px;
  height: 16px;
  cursor: nwse-resize;
  z-index: 10;
}
#usage-float-panel .ufp-resize::after {
  content: '';
  position: absolute;
  right: 4px;
  bottom: 4px;
  width: 8px;
  height: 8px;
  border-right: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
  opacity: 0.5;
}
#usage-float-panel .ufp-resize:hover::after { opacity: 1; }

#usage-float-panel .ufp-header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 16px;
  background: rgba(243, 139, 168, 0.12);
  border-bottom: 1px solid var(--border);
  cursor: grab;
}

#usage-float-panel .ufp-header:active { cursor: grabbing; }

#usage-float-panel .ufp-header .ufp-info {
  flex: 1;
  min-width: 0;
}

#usage-float-panel .ufp-header .ufp-title {
  font-size: 14px;
  font-weight: 600;
  color: #f38ba8;
  line-height: 1.3;
}

#usage-float-panel .ufp-header .ufp-count {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 4px;
  line-height: 1.3;
}

#usage-float-panel .ufp-header .ufp-count .count-num {
  font-weight: 700;
  font-size: 14px;
  color: #fab387;
}

#usage-float-panel .ufp-header .ufp-buttons {
  display: flex;
  gap: 4px;
  align-items: center;
  flex-shrink: 0;
}

#usage-float-panel .ufp-header .refresh-btn,
#usage-float-panel .ufp-header .close-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

#usage-float-panel .ufp-header .close-btn {
  font-size: 18px;
}

#usage-float-panel .ufp-header .refresh-btn:hover,
#usage-float-panel .ufp-header .close-btn:hover { 
  background: var(--bg-hover); 
  color: var(--text-primary);
}

#usage-float-panel .ufp-list {
  flex: 1;
  overflow-y: auto;
  max-height: 300px;
}

#usage-float-panel .ufp-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 10px 16px;
  font-size: 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
  transition: background 0.1s;
}

#usage-float-panel .ufp-item:last-child { border-bottom: none; }
#usage-float-panel .ufp-item:hover { background: var(--bg-hover); }
#usage-float-panel .ufp-item.active { background: rgba(212, 162, 127, 0.2); border-left: 3px solid var(--accent); margin-left: -3px; padding-left: 19px; }

#usage-float-panel .ufp-item .ufp-loc {
  display: flex;
  align-items: center;
  gap: 8px;
}

#usage-float-panel .ufp-item .ufp-file {
  color: var(--text-muted);
  font-size: 11px;
}

#usage-float-panel .ufp-item .ufp-func {
  color: #89dceb;
  font-weight: 600;
  font-size: 12px;
}

#usage-float-panel .ufp-item .ufp-func::before {
  content: 'func ';
  color: var(--gd-keyword);
  font-weight: normal;
}

#usage-float-panel .ufp-item .ufp-line {
  color: var(--text-muted);
  font-size: 10px;
  margin-left: auto;
}

#usage-float-panel .ufp-item .ufp-code {
  color: var(--text-secondary);
  font-family: 'SF Mono', Monaco, monospace;
  font-size: 11px;
  background: var(--bg-tertiary);
  padding: 6px 10px;
  border-radius: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#usage-float-panel .ufp-item .ufp-code .highlight {
  color: #f38ba8;
  font-weight: 600;
  background: rgba(243, 139, 168, 0.15);
  padding: 1px 3px;
  border-radius: 2px;
}

#usage-float-panel .ufp-item .ufp-file {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 2px;
}

#usage-float-panel .ufp-actions {
  display: flex;
  gap: 10px;
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  background: var(--bg-tertiary);
}

#usage-float-panel .ufp-actions button {
  flex: 1;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
  font-weight: 500;
}

#usage-float-panel .ufp-actions .cancel {
  background: var(--bg-secondary);
  color: var(--text-secondary);
}

#usage-float-panel .ufp-actions .delete {
  background: rgba(243, 139, 168, 0.2);
  color: #f38ba8;
  border-color: rgba(243, 139, 168, 0.4);
}

#usage-float-panel .ufp-actions .delete:hover {
  background: rgba(243, 139, 168, 0.3);
}

/* Highlight line in function viewer */
.code-line-highlight {
  background: rgba(243, 139, 168, 0.25) !important;
  border-left: 3px solid #f38ba8 !important;
  margin-left: -14px !important;
  padding-left: 11px !important;
}

/* Add item form */
.add-item-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 10px;
  color: var(--text-muted);
  font-size: 12px;
  cursor: pointer;
  border-radius: 6px;
  margin-top: 4px;
}
.add-item-btn:hover { background: var(--bg-secondary); color: var(--text-secondary); }
.add-item-btn svg { opacity: 0.6; }

.add-item-form {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  margin-top: 8px;
}
.add-item-form .form-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}
.add-item-form .form-row:last-child { margin-bottom: 0; }
.add-item-form input, .add-item-form select {
  flex: 1;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-family: inherit;
}
.add-item-form input:focus, .add-item-form select:focus {
  outline: none;
  border-color: var(--accent);
}
.add-item-form .form-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
.add-item-form button {
  padding: 6px 14px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
}
.add-item-form button.cancel {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}
.add-item-form button.confirm {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
  font-weight: 600;
}

/* Syntax tokens */
.kw { color: var(--gd-keyword); font-weight: 600; }
.fn { color: var(--gd-func-name); }
.tp { color: var(--gd-type); }
.str { color: var(--gd-string); }
.num { color: var(--gd-number); }
.cmt { color: var(--gd-comment); font-style: italic; }
.sig { color: var(--gd-signal); }
.exp { color: var(--gd-export); }
.param { color: var(--text-secondary); }
.ret { color: var(--text-muted); }

/* Tags */
.tag {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: -apple-system, system-ui, sans-serif;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.tag-export { background: #3d3520; color: var(--gd-export); }
.tag-signal { background: #1e3326; color: var(--gd-signal); }
.tag-lines { background: var(--bg-tertiary); color: var(--text-muted); font-weight: normal; }
.tag-return { background: #1e2a3a; color: var(--gd-type); }

/* Function viewer */
.func-viewer {
  margin-top: 16px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  overflow: hidden;
}

.func-viewer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  color: var(--text-secondary);
}

.func-viewer-header .func-title { color: var(--gd-func-name); font-weight: 600; }

.func-viewer-close {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 14px;
  padding: 2px 6px;
  border-radius: 4px;
}

.func-viewer-close:hover { color: var(--text-primary); background: var(--bg-hover); }

.func-viewer-code {
  position: relative;
  padding: 12px 0;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  font-size: 12px;
  line-height: 1.6;
  overflow: auto;
  tab-size: 4;
}

/* Editable code area */
.code-editor-container {
  position: relative;
  margin: 0 14px;
}

.code-editor-textarea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  tab-size: inherit;
  padding: 0;
  margin: 0;
  border: none;
  background: transparent;
  color: transparent;
  caret-color: var(--text-primary);
  resize: none;
  outline: none;
  overflow: hidden;
  white-space: pre;
}

.code-editor-textarea::selection {
  background: rgba(255, 255, 255, 0.2);
}

.code-editor-highlight {
  white-space: pre;
  pointer-events: none;
}

.code-editor-container:focus-within {
  outline: 1px solid var(--accent);
  outline-offset: 4px;
  border-radius: 4px;
}

.func-viewer-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 14px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text-muted);
}

.func-viewer-footer .status { opacity: 0; transition: opacity 0.2s; }
.func-viewer-footer .status.visible { opacity: 1; }
.func-viewer-footer .save-btn {
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.2s;
}
.func-viewer-footer .save-btn.active { opacity: 1; }
.func-viewer-footer .save-btn.active:hover { background: var(--accent-light); }

.code-line {
  display: block;
  padding: 0 14px;
  min-height: 1.4em;
  white-space: pre;
}

.code-line:hover { background: rgba(255,255,255,0.03); }

.line-num {
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
  padding-right: 16px;
  user-select: none;
  flex-shrink: 0;
  font-size: 11px;
}

.line-content {
  white-space: pre;
  flex: 1;
}
</style>
</head>
<body>
<div id="search-bar">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
  <input type="text" id="search" placeholder="Search scripts..." />
  <span class="stats" id="stats"></span>
</div>

<div id="legend">
  <div class="item"><div class="line" style="background:var(--edge-extends)"></div> extends</div>
  <div class="item"><div class="line" style="background:var(--edge-preload)"></div> preload</div>
  <div class="item"><div class="line" style="background:var(--edge-signal);height:0;border-top:2px dotted var(--edge-signal)"></div> signal</div>
</div>

<div id="zoom-indicator" onclick="resetZoom()" title="Click to reset zoom">
  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><path d="M8 11h6"/><path d="M11 8v6"/></svg>
  <span class="zoom-text" id="zoom-text">100%</span>
</div>

<div id="detail-panel">
  <div id="panel-resize-handle"></div>
  <div class="panel-header">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="panel-title"></h2>
    <div class="path" id="panel-path"></div>
  </div>
  <div class="panel-body" id="panel-body"></div>
</div>

<!-- View Tabs -->
<div id="view-tabs">
  <button class="active" onclick="switchView('scripts')">Scripts</button>
  <button onclick="switchView('scenes')">Scenes</button>
</div>

<!-- Context Menu -->
<div id="context-menu">
  <div class="menu-item" onclick="createNewScript()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <polyline points="14,2 14,8 20,8"/>
      <line x1="12" y1="18" x2="12" y2="12"/>
      <line x1="9" y1="15" x2="15" y2="15"/>
    </svg>
    New Script
  </div>
  <div class="menu-divider"></div>
  <div class="menu-item" onclick="refreshProject()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M23 4v6h-6M1 20v-6h6"/>
      <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
    </svg>
    Refresh
  </div>
</div>

<!-- Floating Usage Panel -->
<div id="usage-float-panel">
  <div class="ufp-header" id="ufp-header">
    <div class="ufp-info">
      <div class="ufp-title" id="ufp-title">⚠ Delete Variable</div>
      <div class="ufp-count" id="ufp-count"></div>
    </div>
    <div class="ufp-buttons">
      <button class="refresh-btn" onclick="refreshUsages()" title="Re-scan for usages">↻</button>
      <button class="close-btn" onclick="closeUsagePanel()" title="Cancel">×</button>
    </div>
  </div>
  <div class="ufp-list" id="ufp-list"></div>
  <div class="ufp-actions">
    <button class="cancel" onclick="closeUsagePanel()">Cancel</button>
    <button class="delete" id="ufp-delete-btn">Delete Anyway</button>
  </div>
  <div class="ufp-resize" id="ufp-resize"></div>
</div>

<!-- New Script Modal -->
<div id="new-script-modal" class="modal" style="display:none">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Create New Script</h3>
      <button class="close-btn" onclick="closeNewScriptModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Script Path</label>
        <input type="text" id="new-script-path" placeholder="res://scripts/my_script.gd">
      </div>
      <div class="form-group">
        <label>Extends</label>
        <select id="new-script-extends">
          <option value="Node">Node</option>
          <option value="Node2D">Node2D</option>
          <option value="Node3D">Node3D</option>
          <option value="CharacterBody2D">CharacterBody2D</option>
          <option value="CharacterBody3D">CharacterBody3D</option>
          <option value="RigidBody2D">RigidBody2D</option>
          <option value="Area2D">Area2D</option>
          <option value="Control">Control</option>
          <option value="Resource">Resource</option>
          <option value="RefCounted">RefCounted</option>
        </select>
      </div>
      <div class="form-group">
        <label>Class Name (optional)</label>
        <input type="text" id="new-script-classname" placeholder="MyClass">
      </div>
    </div>
    <div class="modal-footer">
      <button class="cancel" onclick="closeNewScriptModal()">Cancel</button>
      <button class="confirm" onclick="submitNewScript()">Create</button>
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
const PROJECT_DATA = "%%PROJECT_DATA%%";

// ---- WebSocket for real-time edits ----
let ws = null;
let wsConnected = false;
let pendingRequests = new Map();
let requestId = 0;

function connectWebSocket() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${window.location.host}`);
  
  ws.onopen = () => {
    wsConnected = true;
    console.log('[visualizer] WebSocket connected');
  };
  
  ws.onclose = () => {
    wsConnected = false;
    console.log('[visualizer] WebSocket disconnected, reconnecting...');
    setTimeout(connectWebSocket, 2000);
  };
  
  ws.onerror = (err) => {
    console.error('[visualizer] WebSocket error:', err);
  };
  
  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      if (msg.id && pendingRequests.has(msg.id)) {
        const { resolve, reject } = pendingRequests.get(msg.id);
        pendingRequests.delete(msg.id);
        if (msg.error) {
          reject(new Error(msg.error));
        } else {
          resolve(msg);
        }
      }
    } catch (e) {
      console.error('[visualizer] Failed to parse message:', e);
    }
  };
}

function sendCommand(command, args) {
  return new Promise((resolve, reject) => {
    if (!wsConnected) {
      reject(new Error('Not connected to server'));
      return;
    }
    const id = String(++requestId);
    pendingRequests.set(id, { resolve, reject });
    ws.send(JSON.stringify({ id, command, args }));
    
    // Timeout after 10 seconds
    setTimeout(() => {
      if (pendingRequests.has(id)) {
        pendingRequests.delete(id);
        reject(new Error('Request timeout'));
      }
    }, 10000);
  });
}

// Connect on load
connectWebSocket();

// ---- State ----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const searchInput = document.getElementById('search');
const statsEl = document.getElementById('stats');
const detailPanel = document.getElementById('detail-panel');
const zoomIndicator = document.getElementById('zoom-indicator');
const zoomText = document.getElementById('zoom-text');

let W, H;
let camera = { x: 0, y: 0, zoom: 1 };
let defaultZoom = 1;
let dragging = null;
let hoveredNode = null;
let selectedNode = null;
let searchTerm = '';

// Update zoom indicator
function updateZoomIndicator() {
  const percent = Math.round(camera.zoom * 100);
  zoomText.textContent = percent + '%';
  
  // Fade when at default zoom (within 1% tolerance)
  const isDefault = Math.abs(camera.zoom - defaultZoom) < 0.01;
  zoomIndicator.classList.toggle('faded', isDefault);
}

// Reset zoom to default
function resetZoom() {
  camera.zoom = defaultZoom;
  
  // Re-center the view
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(n => { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); });
  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;
  
  updateZoomIndicator();
  draw();
}

// ---- Folder colors ----
const FOLDER_COLORS = [
  'var(--accent)', '#7aa2f7', '#a6e3a1', '#f38ba8', '#cba6f7',
  '#f9e2af', '#94e2d5', '#89dceb', '#fab387', '#f5c2e7'
];
const folderColorMap = {};
let folderColorIdx = 0;

function getFolderColor(folder) {
  if (!folderColorMap[folder]) {
    folderColorMap[folder] = FOLDER_COLORS[folderColorIdx % FOLDER_COLORS.length];
    folderColorIdx++;
  }
  return folderColorMap[folder];
}

// ---- Node layout ----
const NODE_W = 200;
const NODE_H = 54;
const nodes = PROJECT_DATA.nodes.map((n, i) => ({
  ...n,
  x: 0, y: 0,
  color: getFolderColor(n.folder),
  highlighted: true,
  visible: true
}));

const edges = PROJECT_DATA.edges;

// Force-directed layout
function initLayout() {
  const count = nodes.length;
  if (count === 0) return;

  const radius = Math.max(200, count * 45);
  nodes.forEach((n, i) => {
    const angle = (i / count) * Math.PI * 2;
    n.x = Math.cos(angle) * radius;
    n.y = Math.sin(angle) * radius;
  });

  const pathIdx = {};
  nodes.forEach((n, i) => pathIdx[n.path] = i);

  const iterations = 300;
  for (let iter = 0; iter < iterations; iter++) {
    const alpha = 1 - iter / iterations;
    const repulsion = 60000;
    const attraction = 0.004;

    for (let i = 0; i < count; i++) {
      for (let j = i + 1; j < count; j++) {
        let dx = nodes[j].x - nodes[i].x;
        let dy = nodes[j].y - nodes[i].y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 1;
        let force = repulsion / (dist * dist);
        let fx = (dx / dist) * force * alpha;
        let fy = (dy / dist) * force * alpha;
        nodes[i].x -= fx; nodes[i].y -= fy;
        nodes[j].x += fx; nodes[j].y += fy;
      }
    }

    for (const e of edges) {
      const si = pathIdx[e.from], ti = pathIdx[e.to];
      if (si === undefined || ti === undefined) continue;
      let dx = nodes[ti].x - nodes[si].x;
      let dy = nodes[ti].y - nodes[si].y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = dist * attraction * alpha;
      let fx = (dx / dist) * force, fy = (dy / dist) * force;
      nodes[si].x += fx; nodes[si].y += fy;
      nodes[ti].x -= fx; nodes[ti].y -= fy;
    }

    let cx = 0, cy = 0;
    nodes.forEach(n => { cx += n.x; cy += n.y; });
    cx /= count; cy /= count;
    nodes.forEach(n => { n.x -= cx * 0.01; n.y -= cy * 0.01; });
  }
}

// ---- Rendering ----
function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * devicePixelRatio;
  canvas.height = H * devicePixelRatio;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

function screenToWorld(sx, sy) {
  return { x: (sx - W / 2) / camera.zoom + camera.x, y: (sy - H / 2) / camera.zoom + camera.y };
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  const pathIdx = {};
  nodes.forEach((n, i) => pathIdx[n.path] = i);

  // Group edges by node pair, type, and direction for bundled drawing
  const edgeGroups = {};
  for (const e of edges) {
    const si = pathIdx[e.from], ti = pathIdx[e.to];
    if (si === undefined || ti === undefined) continue;
    
    // For signal connections, keep direction (A->B is different from B->A)
    // For extends/preload, also keep direction as they're inherently directional
    const key = `${si}-${ti}-${e.type}`;
    if (!edgeGroups[key]) {
      edgeGroups[key] = { from: e.from, to: e.to, type: e.type, edges: [], si, ti };
    }
    edgeGroups[key].edges.push(e);
  }
  
  // Draw bundled edges
  for (const key of Object.keys(edgeGroups)) {
    const group = edgeGroups[key];
    const s = nodes[group.si], t = nodes[group.ti];
    const count = group.edges.length;
    
    // Skip edges where both nodes are hidden during search
    if (searchTerm && s.visible === false && t.visible === false) continue;

    // Dim edges when one node is hidden, or when neither is highlighted
    const bothVisible = s.visible !== false && t.visible !== false;
    ctx.globalAlpha = (!bothVisible || (!s.highlighted && !t.highlighted)) ? 0.08 : 0.5;
    
    // Calculate perpendicular offset for multiple edge types between same nodes
    const angle = Math.atan2(t.y - s.y, t.x - s.x);
    const perpAngle = angle + Math.PI / 2;
    
    // Get offset based on edge type (so different types don't overlap)
    const typeOffset = group.type === 'extends' ? 0 : group.type === 'preload' ? 8 : 16;
    const offsetX = Math.cos(perpAngle) * typeOffset / camera.zoom;
    const offsetY = Math.sin(perpAngle) * typeOffset / camera.zoom;
    
    ctx.beginPath();
    ctx.moveTo(s.x + offsetX, s.y + offsetY);
    ctx.lineTo(t.x + offsetX, t.y + offsetY);

    if (group.type === 'extends') {
      ctx.strokeStyle = '#7aa2f7'; ctx.setLineDash([]); ctx.lineWidth = 2 / camera.zoom;
    } else if (group.type === 'preload') {
      ctx.strokeStyle = '#d4a27f'; ctx.setLineDash([]); ctx.lineWidth = 1.5 / camera.zoom;
    } else {
      ctx.strokeStyle = '#a6e3a1';
      ctx.setLineDash([4 / camera.zoom, 4 / camera.zoom]);
      ctx.lineWidth = 1.5 / camera.zoom;
    }
    ctx.stroke(); ctx.setLineDash([]);

    // Arrow at midpoint
    const al = 10 / camera.zoom;
    const mx = (s.x + t.x) / 2 + offsetX, my = (s.y + t.y) / 2 + offsetY;
    ctx.beginPath();
    ctx.moveTo(mx + Math.cos(angle) * al, my + Math.sin(angle) * al);
    ctx.lineTo(mx + Math.cos(angle + 2.5) * al * 0.6, my + Math.sin(angle + 2.5) * al * 0.6);
    ctx.lineTo(mx + Math.cos(angle - 2.5) * al * 0.6, my + Math.sin(angle - 2.5) * al * 0.6);
    ctx.closePath(); ctx.fillStyle = ctx.strokeStyle; ctx.fill();
    
    // Draw count badge if multiple connections of same type
    if (count > 1) {
      const badgeX = mx + Math.cos(perpAngle) * (12 / camera.zoom);
      const badgeY = my + Math.sin(perpAngle) * (12 / camera.zoom);
      const badgeSize = 16 / camera.zoom;
      
      ctx.globalAlpha = bothVisible ? 0.9 : 0.3;
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
      
      // Count text
      ctx.fillStyle = '#1a1a1e';
      ctx.font = `bold ${10 / camera.zoom}px -apple-system, system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(count.toString(), badgeX, badgeY);
    }
  }

  ctx.globalAlpha = 1;

  // Draw nodes
  for (const n of nodes) {
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;
    
    const x = n.x - NODE_W / 2, y = n.y - NODE_H / 2;
    const isHovered = n === hoveredNode, isSelected = n === selectedNode;

    ctx.globalAlpha = n.highlighted ? 1 : 0.12;

    // Shadow
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = isHovered ? 16 : 8;
    ctx.shadowOffsetY = 2;

    // Background
    ctx.beginPath(); roundRect(ctx, x, y, NODE_W, NODE_H, 10);
    ctx.fillStyle = isSelected ? '#35353b' : isHovered ? '#303036' : '#242428';
    ctx.fill();

    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

    // Border
    ctx.strokeStyle = isSelected ? n.color : isHovered ? n.color : '#3a3a40';
    ctx.lineWidth = (isSelected ? 2 : 1) / camera.zoom;
    ctx.stroke();

    // Left accent bar
    ctx.beginPath();
    ctx.roundRect(x + 4, y + 8, 3, NODE_H - 16, 2);
    ctx.fillStyle = n.color;
    ctx.fill();

    // Title - scales with zoom
    const fs = 14;
    ctx.font = `600 ${fs}px -apple-system, system-ui, sans-serif`;
    ctx.fillStyle = '#e8e4df';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    const displayName = n.class_name || n.filename.replace('.gd', '');
    ctx.fillText(displayName, x + 16, y + NODE_H / 2 - fs * 0.45);

    // Subtitle with colored stats - scales with zoom
    const ss = 10.5;
    const varCount = n.variables ? n.variables.length : 0;
    const funcCount = n.functions ? n.functions.length : 0;
    const sigCount = n.signals ? n.signals.length : 0;
    
    // Draw subtitle parts with colors
    ctx.font = `${ss}px -apple-system, system-ui, sans-serif`;
    const subY = y + NODE_H / 2 + fs * 0.65;
    let subX = x + 16;
    
    // Extends
    ctx.fillStyle = '#706c66';
    const extendsText = (n.extends || 'Node') + ' · ';
    ctx.fillText(extendsText, subX, subY);
    subX += ctx.measureText(extendsText).width;
    
    // Functions (cyan/teal)
    ctx.fillStyle = '#89dceb';
    ctx.fillText(funcCount + 'f', subX, subY);
    subX += ctx.measureText(funcCount + 'f').width;
    
    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;
    
    // Variables (purple)
    ctx.fillStyle = '#cba6f7';
    ctx.fillText(varCount + 'v', subX, subY);
    subX += ctx.measureText(varCount + 'v').width;
    
    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;
    
    // Signals (green)
    ctx.fillStyle = '#a6e3a1';
    ctx.fillText(sigCount + 's', subX, subY);
    subX += ctx.measureText(sigCount + 's').width;
    
    // Separator
    ctx.fillStyle = '#706c66';
    ctx.fillText(' · ', subX, subY);
    subX += ctx.measureText(' · ').width;
    
    // Lines (yellow/amber)
    ctx.fillStyle = '#f9e2af';
    ctx.fillText(n.line_count + 'L', subX, subY);
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
}

function hitTest(wx, wy) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;
    if (wx >= n.x - NODE_W / 2 && wx <= n.x + NODE_W / 2 &&
        wy >= n.y - NODE_H / 2 && wy <= n.y + NODE_H / 2) return n;
  }
  return null;
}

// ---- GDScript Syntax Highlighting (Godot 4 colors) ----
// Using a tokenizer approach to avoid regex conflicts
const GD_KEYWORDS = new Set([
  'var', 'func', 'signal', 'class_name', 'extends', 'class', 'enum', 'const',
  'if', 'elif', 'else', 'for', 'while', 'match', 'break', 'continue', 'pass', 'return',
  'and', 'or', 'not', 'in', 'is', 'as', 'self', 'super', 'true', 'false', 'null',
  'void', 'await', 'yield', 'static', 'preload', 'load'
]);

const GD_TYPES = new Set([
  'int', 'float', 'bool', 'String', 'Vector2', 'Vector3', 'Vector4', 
  'Color', 'Array', 'Dictionary', 'Object', 'Node', 'Node2D', 'Node3D',
  'Control', 'Resource', 'Variant', 'void'
]);

function highlightGDScript(code) {
  const tokens = [];
  let i = 0;
  
  while (i < code.length) {
    const ch = code[i];
    const rest = code.slice(i);
    
    // Comments
    if (ch === '#') {
      const end = code.indexOf('\n', i);
      const comment = end === -1 ? code.slice(i) : code.slice(i, end);
      tokens.push({ type: 'comment', text: comment });
      i += comment.length;
      continue;
    }
    
    // Strings
    if (ch === '"' || ch === "'") {
      let j = i + 1;
      while (j < code.length && code[j] !== ch) {
        if (code[j] === '\\') j++; // skip escaped char
        j++;
      }
      const str = code.slice(i, j + 1);
      tokens.push({ type: 'string', text: str });
      i = j + 1;
      continue;
    }
    
    // Annotations (@export, @onready, etc.)
    if (ch === '@') {
      const match = rest.match(/^@\w+/);
      if (match) {
        tokens.push({ type: 'annotation', text: match[0] });
        i += match[0].length;
        continue;
      }
    }
    
    // Arrow ->
    if (rest.startsWith('->')) {
      tokens.push({ type: 'arrow', text: '->' });
      i += 2;
      continue;
    }
    
    // Numbers
    if (/\d/.test(ch)) {
      const match = rest.match(/^\d+\.?\d*/);
      if (match) {
        tokens.push({ type: 'number', text: match[0] });
        i += match[0].length;
        continue;
      }
    }
    
    // Words (identifiers, keywords, types, function calls)
    if (/[a-zA-Z_]/.test(ch)) {
      const match = rest.match(/^[a-zA-Z_]\w*/);
      if (match) {
        const word = match[0];
        const afterWord = code.slice(i + word.length);
        const isCallable = /^\s*\(/.test(afterWord);  // followed by (
        
        let type = 'identifier';  // default: white for variables
        if (GD_KEYWORDS.has(word)) type = 'keyword';
        else if (GD_TYPES.has(word) || /^[A-Z]/.test(word)) type = 'type';
        else if (isCallable) type = 'function';  // function/method calls
        
        tokens.push({ type, text: word });
        i += word.length;
        continue;
      }
    }
    
    // Everything else (operators, punctuation, whitespace)
    tokens.push({ type: 'plain', text: ch });
    i++;
  }
  
  // Convert tokens to HTML with Godot-like colors
  return tokens.map(t => {
    const escaped = t.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    switch (t.type) {
      case 'keyword':    return `<span style="color:#FF7085">${escaped}</span>`;      // Pink/red
      case 'type':       return `<span style="color:#8EFFDA">${escaped}</span>`;      // Teal/mint  
      case 'function':   return `<span style="color:#66E6FF">${escaped}</span>`;      // Cyan (function calls)
      case 'string':     return `<span style="color:#FFE566">${escaped}</span>`;      // Yellow
      case 'number':     return `<span style="color:#A3FFB4">${escaped}</span>`;      // Green
      case 'comment':    return `<span style="color:#9A9EA6">${escaped}</span>`;      // Gray
      case 'annotation': return `<span style="color:#FFB373">${escaped}</span>`;      // Orange
      case 'arrow':      return `<span style="color:#ABC8FF">${escaped}</span>`;      // Light blue
      case 'identifier': return `<span style="color:#CDCFD2">${escaped}</span>`;      // White/light gray (variables)
      default:           return escaped;
    }
  }).join('');
}

// ---- Detail Panel ----
function openPanel(node) {
  selectedNode = node;

  document.getElementById('panel-title').textContent = node.class_name || node.filename.replace('.gd', '');
  document.getElementById('panel-path').textContent = node.path;

  let html = '';

  // Description
  if (node.description) {
    html += `<div class="desc-block">${esc(node.description)}</div>`;
  }

  // Meta badges
  html += `<div class="meta-row">`;
  html += `<div class="meta-badge"><span>${node.line_count}</span> lines</div>`;
  html += `<div class="meta-badge">extends <span>${node.extends || 'Node'}</span></div>`;
  if (node.class_name) html += `<div class="meta-badge">class <span>${esc(node.class_name)}</span></div>`;
  html += `</div>`;

  // Variables - split into @export and regular
  const exportVars = (node.variables || []).filter(v => v.exported);
  const regularVars = (node.variables || []).filter(v => !v.exported);

  // Exports section (always show for adding)
  html += `<div class="section">`;
  html += `<div class="section-header">Exports <span class="section-count">${exportVars.length}</span></div>`;
  html += `<ul class="item-list" id="exports-list">`;
  for (let vi = 0; vi < exportVars.length; vi++) {
    const v = exportVars[vi];
    html += `<li data-var-index="${vi}" data-exported="true">`;
    html += `<span class="exp">@export</span> `;
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, true, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(true)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add export</div>`;
  html += `</div>`;

  // Variables section (always show for adding)
  html += `<div class="section">`;
  html += `<div class="section-header">Variables <span class="section-count">${regularVars.length}</span></div>`;
  html += `<ul class="item-list" id="vars-list">`;
  for (let vi = 0; vi < regularVars.length; vi++) {
    const v = regularVars[vi];
    html += `<li data-var-index="${vi}" data-exported="false" data-onready="${v.onready || false}">`;
    if (v.onready) {
      html += `<span class="onready-badge" onclick="toggleOnready(${vi}, false)" title="Click to toggle @onready">@onready</span>`;
    }
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    if (!v.onready) {
      html += `<button onclick="toggleOnready(${vi}, false)" title="Add @onready" style="font-size:9px;width:auto;padding:0 4px;">⏱</button>`;
    }
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, false, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(false)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add variable</div>`;
  html += `</div>`;

  // Functions
  if ((node.functions || []).length > 0) {
    html += `<div class="section">`;
    html += `<div class="section-header">Functions <span class="section-count">${node.functions.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (let fi = 0; fi < node.functions.length; fi++) {
      const f = node.functions[fi];
      html += `<li class="clickable" onclick="toggleFunc(${fi})">`;
      html += `<span class="kw">func</span> <span class="fn">${esc(f.name)}</span>`;
      html += `<span class="param">(${esc(f.params)})</span>`;
      if (f.return_type) html += ` <span class="ret">&rarr;</span> <span class="tp">${esc(f.return_type)}</span>`;
      html += `<span style="margin-left:auto;display:flex;gap:4px;align-items:center">`;
      if (f.body_lines) html += `<span class="tag tag-lines">${f.body_lines}L</span>`;
      html += `<button class="delete" onclick="event.stopPropagation();showDeleteUsages(${fi}, false, 'function')" title="Delete function" style="opacity:0">×</button>`;
      html += `</span>`;
      html += `</li>`;
      html += `<div id="func-viewer-${fi}" class="func-viewer" style="display:none"></div>`;
    }
    html += `</ul></div>`;
  }

  // Signals section (always show for adding)
  const signalsList = node.signals || [];
  html += `<div class="section">`;
  html += `<div class="section-header">Signals <span class="section-count">${signalsList.length}</span></div>`;
  html += `<ul class="item-list" id="signals-list">`;
  for (let si = 0; si < signalsList.length; si++) {
    const s = signalsList[si];
    const sigName = typeof s === 'string' ? s : s.name;
    const sigParams = typeof s === 'object' ? s.params : '';
    html += `<li data-signal-index="${si}">`;
    html += `<span class="kw">signal</span> `;
    html += `<span class="sig editable signal-name" contenteditable="true" data-field="name" data-original="${esc(sigName)}">${esc(sigName)}</span>`;
    html += `<span class="param">(</span>`;
    html += `<span class="editable signal-params" contenteditable="true" data-field="params" data-placeholder="params" data-original="${esc(sigParams)}">${esc(sigParams)}</span>`;
    html += `<span class="param">)</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${si}, false, 'signal')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewSignal()">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add signal</div>`;
  html += `</div>`;

  // Connections - group by target and show signal names
  const related = edges.filter(e => e.from === node.path || e.to === node.path);
  if (related.length > 0) {
    // Group connections by target and type
    const connGroups = {};
    for (const e of related) {
      const other = e.from === node.path ? e.to : e.from;
      const dir = e.from === node.path ? 'out' : 'in';
      const key = `${other}-${e.type}-${dir}`;
      if (!connGroups[key]) {
        connGroups[key] = { other, type: e.type, dir, signals: [] };
      }
      if (e.signal_name) connGroups[key].signals.push(e.signal_name);
    }
    
    html += `<div class="section">`;
    html += `<div class="section-header">Connections <span class="section-count">${related.length}</span></div>`;
    html += `<ul class="item-list">`;
    
    for (const key of Object.keys(connGroups)) {
      const g = connGroups[key];
      const dirIcon = g.dir === 'out' ? '→' : '←';
      const color = g.type === 'extends' ? 'var(--edge-extends)' : g.type === 'preload' ? 'var(--edge-preload)' : 'var(--edge-signal)';
      const filename = g.other.split('/').pop();
      
      html += `<li style="flex-wrap:wrap">`;
      html += `${dirIcon} <span style="color:${color}">${esc(filename)}</span> <span class="ret">(${g.type})</span>`;
      
      // Show signal names if this is a signal connection
      if (g.type === 'signal' && g.signals.length > 0) {
        const uniqueSignals = [...new Set(g.signals)];
        html += `<div style="width:100%;margin-top:4px;padding-left:20px;font-size:11px;color:var(--text-muted)">`;
        html += uniqueSignals.map(s => `<span class="sig">${esc(s)}</span>`).join(', ');
        html += `</div>`;
      }
      html += `</li>`;
    }
    html += `</ul></div>`;
  }

  // Preloads
  if ((node.preloads || []).length > 0) {
    html += `<div class="section">`;
    html += `<div class="section-header">Preloads <span class="section-count">${node.preloads.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (const p of node.preloads) {
      html += `<li><span class="str">"${esc(p)}"</span></li>`;
    }
    html += `</ul></div>`;
  }

  document.getElementById('panel-body').innerHTML = html;
  detailPanel.classList.add('open');
  initSectionResizing();
  initInlineEditing();
  draw();
}

// Toggle function body viewer with inline editing
window.toggleFunc = function(fi) {
  const viewer = document.getElementById(`func-viewer-${fi}`);
  if (!viewer) return;

  if (viewer.style.display !== 'none') {
    viewer.style.display = 'none';
    viewer.innerHTML = '';
    return;
  }

  const f = selectedNode.functions[fi];
  if (!f.body) return;

  const editorId = `code-editor-${fi}`;
  
  viewer.innerHTML = `
    <div class="func-viewer-header">
      <span><span class="func-title">${esc(f.name)}</span> · <span id="line-count-${fi}">${f.body.split('\n').length}</span> lines</span>
      <button class="func-viewer-close" onclick="toggleFunc(${fi})">&times;</button>
    </div>
    <div class="func-viewer-code">
      <div class="code-editor-container" id="${editorId}">
        <div class="code-editor-highlight" id="highlight-${fi}"></div>
        <textarea class="code-editor-textarea" id="textarea-${fi}" spellcheck="false"></textarea>
      </div>
    </div>
    <div class="func-viewer-footer">
      <span class="status" id="status-${fi}">Modified</span>
      <span style="display:flex;gap:8px;align-items:center">
        <span style="opacity:0.6">Ctrl+S to save</span>
        <button class="save-btn" id="save-btn-${fi}" onclick="saveFunction(${fi})">Save</button>
      </span>
    </div>
  `;
  
  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);
  const lineCountEl = document.getElementById(`line-count-${fi}`);
  
  // Store original code for comparison
  textarea.dataset.original = f.body;
  textarea.dataset.funcIndex = fi;
  textarea.dataset.scriptPath = selectedNode.path;
  textarea.dataset.funcName = f.name;
  textarea.value = f.body;
  
  // Initial highlight
  updateHighlight(fi);
  
  // Sync highlight on input
  textarea.addEventListener('input', () => {
    updateHighlight(fi);
    const modified = textarea.value !== textarea.dataset.original;
    statusEl.classList.toggle('visible', modified);
    saveBtn.classList.toggle('active', modified);
    lineCountEl.textContent = textarea.value.split('\n').length;
  });
  
  // Sync scroll
  textarea.addEventListener('scroll', () => {
    highlight.style.transform = `translate(-${textarea.scrollLeft}px, -${textarea.scrollTop}px)`;
  });
  
  // Handle tab key
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      textarea.value = textarea.value.substring(0, start) + '\t' + textarea.value.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + 1;
      textarea.dispatchEvent(new Event('input'));
    }
    // Ctrl+S to save
    if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      saveFunction(fi);
    }
  });
  
  // Auto-resize textarea height
  function autoResize() {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
    highlight.style.height = textarea.scrollHeight + 'px';
  }
  textarea.addEventListener('input', autoResize);
  setTimeout(autoResize, 0);
  
  viewer.style.display = 'block';
};

// Update syntax highlighting
function updateHighlight(fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  if (!textarea || !highlight) return;
  
  // Highlight each line, wrap in spans for line-level highlighting
  const lines = textarea.value.split('\n');
  highlight.innerHTML = lines.map((line, i) => 
    `<div class="code-line" data-line="${i}">${highlightGDScript(line) || ' '}</div>`
  ).join('');
}

// Save function changes back to Godot
async function saveFunction(fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);
  
  if (!textarea || textarea.value === textarea.dataset.original) return;
  
  const scriptPath = textarea.dataset.scriptPath;
  const funcName = textarea.dataset.funcName;
  const newCode = textarea.value;
  
  statusEl.textContent = 'Saving...';
  statusEl.classList.add('visible');
  
  try {
    // Send to Godot
    await sendCommand('modify_function', {
      path: scriptPath,
      name: funcName,
      body: newCode
    });
    
    // Update local state
    const funcIndex = parseInt(textarea.dataset.funcIndex);
    selectedNode.functions[funcIndex].body = newCode;
    selectedNode.functions[funcIndex].body_lines = newCode.split('\n').length;
    
    textarea.dataset.original = newCode;
    statusEl.textContent = 'Saved!';
    saveBtn.classList.remove('active');
    
    setTimeout(() => {
      statusEl.classList.remove('visible');
    }, 2000);
    
    console.log(`Saved function "${funcName}" in ${scriptPath}`);
  } catch (err) {
    statusEl.textContent = 'Error: ' + err.message;
    console.error('Failed to save:', err);
  }
}

function closePanel() {
  selectedNode = null;
  detailPanel.classList.remove('open');
  draw();
}

// ---- Inline Editing for Variables/Signals ----
function initInlineEditing() {
  // Handle blur on editable fields - save changes
  document.querySelectorAll('.editable').forEach(el => {
    el.addEventListener('blur', handleInlineEdit);
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        el.blur();
      }
      if (e.key === 'Escape') {
        el.textContent = el.dataset.original || '';
        el.blur();
      }
    });
  });
}

async function handleInlineEdit(e) {
  const el = e.target;
  const li = el.closest('li');
  if (!li) return;
  
  const newValue = el.textContent.trim();
  const original = el.dataset.original || '';
  const field = el.dataset.field;
  
  if (newValue === original) return; // No change
  
  // Determine what type of item this is
  const isSignal = li.dataset.signalIndex !== undefined;
  const isExport = li.dataset.exported === 'true';
  const index = parseInt(isSignal ? li.dataset.signalIndex : li.dataset.varIndex);
  
  try {
    if (isSignal) {
      // Update signal
      const sig = selectedNode.signals[index];
      const oldName = typeof sig === 'string' ? sig : sig.name;
      const oldParams = typeof sig === 'object' ? sig.params : '';
      
      const newSig = {
        name: field === 'name' ? newValue : oldName,
        params: field === 'params' ? newValue : oldParams
      };
      
      // Send to Godot
      await sendCommand('modify_signal', {
        path: selectedNode.path,
        action: 'update',
        old_name: oldName,
        name: newSig.name,
        params: newSig.params
      });
      
      // Update local state
      selectedNode.signals[index] = newSig;
      console.log(`Updated signal in ${selectedNode.path}:`, newSig);
    } else {
      // Update variable
      const vars = selectedNode.variables.filter(v => v.exported === isExport);
      const v = vars[index];
      const actualIndex = selectedNode.variables.findIndex(vr => vr.name === v.name);
      
      if (actualIndex !== -1) {
        const newVar = { ...selectedNode.variables[actualIndex] };
        if (field === 'name') newVar.name = newValue;
        if (field === 'type') newVar.type = newValue;
        if (field === 'default') newVar.default = newValue;
        
        // Send to Godot
        await sendCommand('modify_variable', {
          path: selectedNode.path,
          action: 'update',
          old_name: v.name,
          name: newVar.name,
          type: newVar.type,
          default: newVar.default,
          exported: isExport
        });
        
        // Update local state
        selectedNode.variables[actualIndex] = newVar;
        console.log(`Updated variable in ${selectedNode.path}:`, newVar);
      }
    }
    
    // Update the original value
    el.dataset.original = newValue;
  } catch (err) {
    console.error('Failed to update:', err);
    // Revert on error
    el.textContent = original;
    alert('Failed to save: ' + err.message);
  }
}

// ---- Toggle @onready ----
async function toggleOnready(index, isExport) {
  const vars = selectedNode.variables.filter(v => v.exported === isExport);
  const v = vars[index];
  const actualIndex = selectedNode.variables.findIndex(vr => vr.name === v.name);
  
  if (actualIndex === -1) return;
  
  const newOnready = !v.onready;
  
  try {
    await sendCommand('modify_variable', {
      path: selectedNode.path,
      action: 'update',
      old_name: v.name,
      name: v.name,
      type: v.type || '',
      default: v.default || '',
      exported: isExport,
      onready: newOnready
    });
    
    selectedNode.variables[actualIndex].onready = newOnready;
    openPanel(selectedNode);
  } catch (err) {
    console.error('Failed to toggle @onready:', err);
    alert('Failed to update: ' + err.message);
  }
}

// ---- Add New Items ----
async function addNewVariable(isExport) {
  const newVar = { name: 'new_var', type: '', default: '', exported: isExport };
  
  try {
    // Send to Godot first
    await sendCommand('modify_variable', {
      path: selectedNode.path,
      action: 'add',
      name: newVar.name,
      type: newVar.type,
      default: newVar.default,
      exported: isExport
    });
    
    // Update local state
    selectedNode.variables.push(newVar);
    openPanel(selectedNode);
    
    // Focus the new variable name after panel refresh
    setTimeout(() => {
      const list = document.getElementById(isExport ? 'exports-list' : 'vars-list');
      const lastItem = list?.querySelector('li:last-of-type .var-name');
      if (lastItem) {
        lastItem.focus();
        const range = document.createRange();
        range.selectNodeContents(lastItem);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }, 50);
  } catch (err) {
    console.error('Failed to add variable:', err);
    alert('Failed to add variable: ' + err.message);
  }
}

async function addNewSignal() {
  const newSig = { name: 'new_signal', params: '' };
  
  try {
    // Send to Godot first
    await sendCommand('modify_signal', {
      path: selectedNode.path,
      action: 'add',
      name: newSig.name,
      params: newSig.params
    });
    
    // Update local state
    if (!selectedNode.signals) selectedNode.signals = [];
    selectedNode.signals.push(newSig);
    openPanel(selectedNode);
    
    setTimeout(() => {
      const list = document.getElementById('signals-list');
      const lastItem = list?.querySelector('li:last-of-type .signal-name');
      if (lastItem) {
        lastItem.focus();
        const range = document.createRange();
        range.selectNodeContents(lastItem);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }, 50);
  } catch (err) {
    console.error('Failed to add signal:', err);
    alert('Failed to add signal: ' + err.message);
  }
}

// ---- Delete with Floating Usage Panel ----
let pendingDelete = null; // { index, isExport, type, itemName }
let currentUsages = []; // Current list of usages

async function showDeleteUsages(index, isExport, type) {
  // Get the item name
  let itemName = '';
  if (type === 'signal') {
    const sig = selectedNode.signals[index];
    itemName = typeof sig === 'string' ? sig : sig.name;
  } else if (type === 'function') {
    const func = selectedNode.functions[index];
    itemName = func?.name || '';
  } else {
    const vars = selectedNode.variables.filter(v => v.exported === isExport);
    itemName = vars[index]?.name || '';
  }
  
  // Store pending delete info and the declaring node
  pendingDelete = { index, isExport, type, itemName, declaringNode: selectedNode };
  
  // Find usages with smart detection
  currentUsages = findUsagesSmart(itemName, type);
  
  if (currentUsages.length === 0) {
    // No usages, delete directly
    await performDelete(index, isExport, type, itemName);
    return;
  }
  
  renderUsagePanel();
}

function renderUsagePanel() {
  if (!pendingDelete) return;
  const { itemName, type } = pendingDelete;
  
  const panel = document.getElementById('usage-float-panel');
  const titleEl = document.getElementById('ufp-title');
  const countEl = document.getElementById('ufp-count');
  const listEl = document.getElementById('ufp-list');
  const deleteBtn = document.getElementById('ufp-delete-btn');
  
  // Set title based on type
  const typeLabel = type === 'signal' ? 'Signal' : type === 'function' ? 'Function' : 'Variable';
  titleEl.innerHTML = `⚠ Delete ${typeLabel}: <span style="color:#f38ba8;font-weight:600">${itemName}</span>`;
  
  if (currentUsages.length === 0) {
    // All usages fixed! Can delete now
    countEl.innerHTML = `<span style="color:#a6e3a1">✓ All usages fixed! Safe to delete.</span>`;
    listEl.innerHTML = '<div style="padding: 30px; text-align: center; color: var(--text-muted);">No more usages found</div>';
    deleteBtn.textContent = 'Delete Now';
    deleteBtn.style.background = 'rgba(166, 227, 161, 0.2)';
    deleteBtn.style.color = '#a6e3a1';
    deleteBtn.style.borderColor = 'rgba(166, 227, 161, 0.4)';
  } else {
    countEl.innerHTML = `Found <span class="count-num">${currentUsages.length}</span> usage${currentUsages.length > 1 ? 's' : ''} — click to navigate`;
    
    listEl.innerHTML = currentUsages.map((u, i) => {
      const highlightedCode = highlightUsageInCode(u.code, itemName);
      const fileName = u.file.split('/').pop().replace('.gd', '');
      return `
        <div class="ufp-item" 
             data-usage-index="${i}" 
             data-file="${u.file}" 
             data-line="${u.line}"
             data-func="${u.funcName || ''}"
             onclick="navigateToUsage(this)">
          <div class="ufp-loc">
            <span class="ufp-func">${u.funcName || 'unknown'}</span>
            <span class="ufp-line">line ${u.line}</span>
          </div>
          <div class="ufp-code">${highlightedCode}</div>
          <div class="ufp-file">${fileName}.gd</div>
        </div>
      `;
    }).join('');
    deleteBtn.textContent = 'Delete Anyway';
    deleteBtn.style.background = '';
    deleteBtn.style.color = '';
    deleteBtn.style.borderColor = '';
  }
  
  deleteBtn.onclick = () => forceDeleteFromPanel();
  
  // Position panel if not already positioned by drag
  if (!panel.dataset.positioned) {
    const detailPanel = document.getElementById('detail-panel');
    const detailWidth = detailPanel.offsetWidth;
    panel.style.right = (detailWidth + 20) + 'px';
    panel.style.top = '80px';
    panel.style.left = 'auto';
  }
  
  panel.classList.add('visible');
  initUsagePanelDrag();
  initUsagePanelResize();
}

function refreshUsages() {
  if (!pendingDelete) return;
  const { itemName, type } = pendingDelete;
  
  // Re-scan for usages
  currentUsages = findUsagesSmart(itemName, type);
  renderUsagePanel();
}

// ---- Draggable Usage Panel ----
let ufpDragging = false;
let ufpDragStart = { x: 0, y: 0 };
let ufpPanelStart = { x: 0, y: 0 };

function initUsagePanelDrag() {
  const header = document.getElementById('ufp-header');
  const panel = document.getElementById('usage-float-panel');
  
  // Remove existing listeners
  header.onmousedown = (e) => {
    if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons
    
    ufpDragging = true;
    panel.classList.add('dragging');
    ufpDragStart = { x: e.clientX, y: e.clientY };
    
    const rect = panel.getBoundingClientRect();
    ufpPanelStart = { x: rect.left, y: rect.top };
    
    document.addEventListener('mousemove', onUfpDrag);
    document.addEventListener('mouseup', onUfpDragEnd);
  };
}

function onUfpDrag(e) {
  if (!ufpDragging) return;
  
  const panel = document.getElementById('usage-float-panel');
  const dx = e.clientX - ufpDragStart.x;
  const dy = e.clientY - ufpDragStart.y;
  
  const newX = ufpPanelStart.x + dx;
  const newY = ufpPanelStart.y + dy;
  
  // Switch to left/top positioning for dragging
  panel.style.left = Math.max(0, newX) + 'px';
  panel.style.top = Math.max(0, newY) + 'px';
  panel.style.right = 'auto';
  panel.dataset.positioned = 'true';
}

function onUfpDragEnd() {
  ufpDragging = false;
  document.getElementById('usage-float-panel')?.classList.remove('dragging');
  document.removeEventListener('mousemove', onUfpDrag);
  document.removeEventListener('mouseup', onUfpDragEnd);
}

// ---- Resizable Usage Panel ----
let ufpResizing = false;
let ufpResizeStart = { x: 0, y: 0, w: 0, h: 0 };

function initUsagePanelResize() {
  const resizeHandle = document.getElementById('ufp-resize');
  const panel = document.getElementById('usage-float-panel');
  
  resizeHandle.onmousedown = (e) => {
    e.preventDefault();
    e.stopPropagation();
    ufpResizing = true;
    ufpResizeStart = {
      x: e.clientX,
      y: e.clientY,
      w: panel.offsetWidth,
      h: panel.offsetHeight
    };
    document.addEventListener('mousemove', onUfpResize);
    document.addEventListener('mouseup', onUfpResizeEnd);
  };
}

function onUfpResize(e) {
  if (!ufpResizing) return;
  const panel = document.getElementById('usage-float-panel');
  
  const dw = e.clientX - ufpResizeStart.x;
  const dh = e.clientY - ufpResizeStart.y;
  
  const newW = Math.max(300, ufpResizeStart.w + dw);
  const newH = Math.max(200, ufpResizeStart.h + dh);
  
  panel.style.width = newW + 'px';
  panel.style.height = newH + 'px';
}

function onUfpResizeEnd() {
  ufpResizing = false;
  document.removeEventListener('mousemove', onUfpResize);
  document.removeEventListener('mouseup', onUfpResizeEnd);
}

function highlightUsageInCode(code, name) {
  const escaped = esc(code);
  // Highlight the variable/signal/function name
  const regex = new RegExp(`\\b(${name})\\b`, 'g');
  return escaped.replace(regex, '<span class="highlight">$1</span>');
}

function closeUsagePanel() {
  const panel = document.getElementById('usage-float-panel');
  panel.classList.remove('visible');
  panel.dataset.positioned = '';
  panel.style.left = '';
  panel.style.right = '';
  panel.style.top = '';
  pendingDelete = null;
  currentUsages = [];
}

function navigateToUsage(el) {
  // Mark this item as active
  document.querySelectorAll('#ufp-list .ufp-item').forEach(item => {
    item.classList.remove('active');
  });
  el.classList.add('active');
  
  const file = el.dataset.file;
  const line = parseInt(el.dataset.line);
  const funcName = el.dataset.func;
  
  // Find the node for this file
  const targetNode = nodes.find(n => n.path === file);
  if (!targetNode) {
    console.log('Node not found for file:', file);
    return;
  }
  
  // If it's a different node, switch to it
  if (selectedNode?.path !== targetNode.path) {
    openPanel(targetNode);
    // Wait for panel to render
    setTimeout(() => {
      if (funcName) {
        expandAndHighlightFunction(funcName, line, targetNode);
      }
    }, 150);
  } else {
    // Same node, just expand/highlight
    if (funcName) {
      expandAndHighlightFunction(funcName, line, targetNode);
    }
  }
}

function expandAndHighlightFunction(funcName, targetLine, nodeData) {
  const node = nodeData || selectedNode;
  
  // Find the function index
  const funcIndex = node.functions.findIndex(f => f.name === funcName);
  if (funcIndex === -1) {
    console.log('Function not found:', funcName);
    return;
  }
  
  console.log(`Expanding function ${funcName} (index ${funcIndex}) to line ${targetLine}`);
  
  // Get the function viewer element
  const viewer = document.getElementById(`func-viewer-${funcIndex}`);
  if (!viewer) {
    console.log('Viewer element not found for index:', funcIndex);
    return;
  }
  
  // Check if already expanded
  const isExpanded = viewer.style.display !== 'none';
  
  if (!isExpanded) {
    // Need to expand - call toggleFunc
    window.toggleFunc(funcIndex);
  }
  
  // Wait for expansion, then highlight
  setTimeout(() => {
    highlightLineInViewer(viewer, funcName, targetLine, node);
    // Scroll the viewer into view
    viewer.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }, isExpanded ? 100 : 300);
}

function highlightLineInViewer(viewer, funcName, targetLine, nodeData) {
  // Find the function to get its start line
  const node = nodeData || selectedNode;
  const func = node.functions.find(f => f.name === funcName);
  if (!func) {
    console.log('Function not found for highlighting:', funcName);
    return;
  }
  
  const funcStartLine = func.line || 1;
  const relativeLineIndex = targetLine - funcStartLine;
  
  console.log(`Highlighting line ${targetLine} in ${funcName} (start: ${funcStartLine}, relative: ${relativeLineIndex})`);
  
  // Find the highlight overlay within the viewer
  const highlightDiv = viewer.querySelector('.code-editor-highlight');
  if (!highlightDiv) {
    console.log('Highlight div not found in viewer');
    return;
  }
  
  // Clear all previous highlights
  document.querySelectorAll('.code-line-highlight').forEach(el => {
    el.classList.remove('code-line-highlight');
  });
  
  // Get all lines and highlight the target
  const lines = highlightDiv.querySelectorAll('.code-line');
  console.log(`Found ${lines.length} lines in viewer`);
  
  if (relativeLineIndex >= 0 && relativeLineIndex < lines.length) {
    const targetLineEl = lines[relativeLineIndex];
    targetLineEl.classList.add('code-line-highlight');
    
    // Scroll the line into view within the code editor
    setTimeout(() => {
      targetLineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 50);
  } else {
    console.log(`Line index ${relativeLineIndex} out of range (0-${lines.length - 1})`);
  }
}

async function performDelete(index, isExport, type, itemName) {
  try {
    if (type === 'signal') {
      await sendCommand('modify_signal', {
        path: selectedNode.path,
        action: 'delete',
        old_name: itemName
      });
      selectedNode.signals.splice(index, 1);
    } else if (type === 'function') {
      await sendCommand('modify_function_delete', {
        path: selectedNode.path,
        name: itemName
      });
      selectedNode.functions.splice(index, 1);
    } else {
      await sendCommand('modify_variable', {
        path: selectedNode.path,
        action: 'delete',
        old_name: itemName
      });
      const vars = selectedNode.variables.filter(v => v.exported === isExport);
      const actualIndex = selectedNode.variables.findIndex(v => v.name === vars[index].name);
      if (actualIndex !== -1) selectedNode.variables.splice(actualIndex, 1);
    }
    console.log(`Deleted ${type} "${itemName}" from ${selectedNode.path}`);
    closeUsagePanel();
    openPanel(selectedNode);
  } catch (err) {
    console.error('Failed to delete:', err);
    alert('Failed to delete: ' + err.message);
  }
}

async function forceDeleteFromPanel() {
  if (!pendingDelete) return;
  const { index, isExport, type, itemName } = pendingDelete;
  await performDelete(index, isExport, type, itemName);
}

// ---- Smart Usage Detection ----
// Avoids false positives like matching "new" in "SomeClass.new()"
function findUsagesSmart(name, type) {
  const usages = [];
  
  // GDScript built-in methods/keywords to avoid false positives
  const builtinMethods = ['new', 'free', 'queue_free', 'get', 'set', 'call', 'emit', 'connect', 'disconnect'];
  const isBuiltinMethod = builtinMethods.includes(name);
  
  for (const node of nodes) {
    // Check if this is the node where the item is declared
    const isDeclaringNode = node.path === selectedNode?.path;
    
    for (const func of (node.functions || [])) {
      if (!func.body) continue;
      
      const lines = func.body.split('\n');
      lines.forEach((line, i) => {
        const lineNum = (func.line || 1) + i;
        
        // Skip the declaration line itself
        if (isDeclaringNode && isDeclarationLine(line, name, type)) {
          return;
        }
        
        // Check if this line actually uses the variable/signal/function
        if (isActualUsage(line, name, type, isBuiltinMethod)) {
          usages.push({
            file: node.path,
            line: lineNum,
            code: line.trim(),
            funcName: func.name
          });
        }
      });
    }
  }
  
  return usages;
}

function isDeclarationLine(line, name, type) {
  const trimmed = line.trim();
  if (type === 'variable') {
    // var name, @export var name, @onready var name
    return new RegExp(`^(@export\\s+)?(@onready\\s+)?var\\s+${name}\\b`).test(trimmed);
  }
  if (type === 'signal') {
    return new RegExp(`^signal\\s+${name}\\b`).test(trimmed);
  }
  if (type === 'function') {
    return new RegExp(`^func\\s+${name}\\s*\\(`).test(trimmed);
  }
  return false;
}

function isActualUsage(line, name, type, isBuiltinMethod) {
  // Build a regex that matches the name as a word boundary
  const namePattern = `\\b${name}\\b`;
  
  if (!new RegExp(namePattern).test(line)) {
    return false; // Name not in line at all
  }
  
  // For variables named like builtins (e.g., "new"), do extra checks
  if (isBuiltinMethod) {
    // Exclude patterns like "ClassName.new()" or ".new()"
    // These are constructor calls, not variable usages
    const constructorPattern = new RegExp(`\\.${name}\\s*\\(`);
    if (constructorPattern.test(line)) {
      // Check if the name appears OUTSIDE of a constructor pattern too
      const withoutConstructors = line.replace(new RegExp(`\\w+\\.${name}\\s*\\([^)]*\\)`, 'g'), '');
      if (!new RegExp(namePattern).test(withoutConstructors)) {
        return false; // Only appears in constructor calls
      }
    }
  }
  
  // For signals, check for signal-specific patterns
  if (type === 'signal') {
    // Match: signal_name.emit(), signal_name.connect(), etc.
    return new RegExp(`\\b${name}\\s*\\.\\s*(emit|connect|disconnect)\\b`).test(line) ||
           new RegExp(`\\.${name}\\s*\\.\\s*(connect|emit)`).test(line);
  }
  
  // For functions, match function calls
  if (type === 'function') {
    return new RegExp(`\\b${name}\\s*\\(`).test(line);
  }
  
  // For variables, the name should appear as a standalone identifier
  // Not as part of another word and not only in a method call position
  return true;
}

// Section resizing
let resizingList = null;
let resizeStartY = 0;
let resizeStartHeight = 0;

function initSectionResizing() {
  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    // Remove old listeners
    handle.replaceWith(handle.cloneNode(true));
  });
  
  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Find the item-list in this section
      const section = handle.closest('.section');
      resizingList = section?.querySelector('.item-list');
      if (!resizingList) return;
      
      section.classList.add('resizing');
      resizeStartY = e.clientY;
      resizeStartHeight = resizingList.offsetHeight;
      
      document.addEventListener('mousemove', onSectionResize);
      document.addEventListener('mouseup', onSectionResizeEnd);
    });
  });
}

function onSectionResize(e) {
  if (!resizingList) return;
  const dy = e.clientY - resizeStartY;
  const newHeight = Math.max(50, Math.min(500, resizeStartHeight + dy));
  resizingList.style.maxHeight = newHeight + 'px';
}

function onSectionResizeEnd() {
  if (resizingList) {
    const section = resizingList.closest('.section');
    section?.classList.remove('resizing');
    resizingList = null;
  }
  document.removeEventListener('mousemove', onSectionResize);
  document.removeEventListener('mouseup', onSectionResizeEnd);
}

// Panel horizontal resizing
let panelResizing = false;
let panelResizeStartX = 0;
let panelStartWidth = 460;

function initPanelResizing() {
  const handle = document.getElementById('panel-resize-handle');
  const panel = document.getElementById('detail-panel');
  
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    panelResizing = true;
    panel.classList.add('resizing');
    panelResizeStartX = e.clientX;
    panelStartWidth = panel.offsetWidth;
    
    document.addEventListener('mousemove', onPanelResize);
    document.addEventListener('mouseup', onPanelResizeEnd);
  });
}

function onPanelResize(e) {
  if (!panelResizing) return;
  const panel = document.getElementById('detail-panel');
  const dx = panelResizeStartX - e.clientX; // Dragging left = wider
  const newWidth = Math.max(300, Math.min(window.innerWidth * 0.8, panelStartWidth + dx));
  panel.style.width = newWidth + 'px';
  panel.style.right = '0';
}

function onPanelResizeEnd() {
  panelResizing = false;
  const panel = document.getElementById('detail-panel');
  panel.classList.remove('resizing');
  document.removeEventListener('mousemove', onPanelResize);
  document.removeEventListener('mouseup', onPanelResizeEnd);
}

// Initialize panel resizing on load
document.addEventListener('DOMContentLoaded', initPanelResizing);

// ---- View Switching (Scripts/Scenes) ----
let currentView = 'scripts';
let sceneData = null;

function switchView(view) {
  if (view === currentView) return;
  currentView = view;
  
  // Update tab buttons
  document.querySelectorAll('#view-tabs button').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase() === view);
  });
  
  if (view === 'scenes') {
    loadSceneView();
  } else {
    draw();
  }
}

async function loadSceneView() {
  // Request scene data from Godot
  try {
    const result = await sendCommand('map_scenes', { root: 'res://' });
    if (result.ok) {
      sceneData = result.scene_map;
      drawSceneView();
    } else {
      console.error('Failed to load scenes:', result.error);
      alert('Failed to load scenes: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    console.error('Failed to load scenes:', err);
    // Show placeholder for now
    drawSceneViewPlaceholder();
  }
}

function drawSceneView() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(camera.x, camera.y);
  ctx.scale(camera.zoom, camera.zoom);
  
  if (!sceneData || !sceneData.scenes || sceneData.scenes.length === 0) {
    drawSceneViewPlaceholder();
    ctx.restore();
    return;
  }
  
  // Draw scene nodes (similar to script nodes but for scenes)
  const scenes = sceneData.scenes;
  scenes.forEach((scene, i) => {
    const x = scene.x || (i % 4) * 250 + 100;
    const y = scene.y || Math.floor(i / 4) * 150 + 100;
    
    // Scene card
    ctx.fillStyle = '#2a4858';
    ctx.strokeStyle = '#3d6b7a';
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, 200, 80, 8, true, true);
    
    // Scene name
    ctx.fillStyle = '#e8e4df';
    ctx.font = '600 14px -apple-system, system-ui, sans-serif';
    ctx.fillText(scene.name || scene.path.split('/').pop(), x + 12, y + 24);
    
    // Scene path
    ctx.fillStyle = '#706c66';
    ctx.font = '11px -apple-system, system-ui, sans-serif';
    ctx.fillText(scene.path, x + 12, y + 42);
    
    // Node count
    const nodeCount = scene.nodes ? scene.nodes.length : 0;
    ctx.fillStyle = '#89dceb';
    ctx.fillText(`${nodeCount} nodes`, x + 12, y + 60);
  });
  
  ctx.restore();
}

function drawSceneViewPlaceholder() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#706c66';
  ctx.font = '16px -apple-system, system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Scene view coming soon...', canvas.width / 2, canvas.height / 2);
  ctx.fillText('Requires scene mapping tool in Godot', canvas.width / 2, canvas.height / 2 + 24);
  ctx.textAlign = 'left';
}

// ---- Context Menu ----
const contextMenu = document.getElementById('context-menu');
let contextMenuPos = { x: 0, y: 0 };

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  
  // Position menu at mouse
  contextMenuPos = { x: e.clientX, y: e.clientY };
  contextMenu.style.left = e.clientX + 'px';
  contextMenu.style.top = e.clientY + 'px';
  contextMenu.classList.add('visible');
});

// Hide context menu on click elsewhere
document.addEventListener('click', (e) => {
  if (!contextMenu.contains(e.target)) {
    contextMenu.classList.remove('visible');
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    contextMenu.classList.remove('visible');
    closeNewScriptModal();
  }
});

// ---- New Script Creation ----
function createNewScript() {
  contextMenu.classList.remove('visible');
  document.getElementById('new-script-modal').style.display = 'flex';
  document.getElementById('new-script-path').focus();
}

function closeNewScriptModal() {
  document.getElementById('new-script-modal').style.display = 'none';
}

async function submitNewScript() {
  const path = document.getElementById('new-script-path').value.trim();
  const extendsType = document.getElementById('new-script-extends').value;
  const className = document.getElementById('new-script-classname').value.trim();
  
  if (!path) {
    alert('Please enter a script path');
    return;
  }
  
  if (!path.startsWith('res://') || !path.endsWith('.gd')) {
    alert('Path must start with res:// and end with .gd');
    return;
  }
  
  try {
    // Use existing create_script tool via invokeTool (not internal)
    const result = await sendCommand('create_script_file', {
      path: path,
      extends: extendsType,
      class_name: className || ''
    });
    
    if (result.ok) {
      closeNewScriptModal();
      // Refresh the project map
      refreshProject();
    } else {
      alert('Failed to create script: ' + (result.error || 'Unknown error'));
    }
  } catch (err) {
    alert('Failed to create script: ' + err.message);
  }
}

async function refreshProject() {
  contextMenu.classList.remove('visible');
  try {
    const result = await sendCommand('refresh_map', {});
    if (result.ok && result.project_map) {
      // Update nodes and edges
      const newNodes = result.project_map.nodes.map((n, i) => ({
        ...n,
        x: nodes[i]?.x || 0,
        y: nodes[i]?.y || 0,
        color: getFolderColor(n.folder),
        highlighted: true,
        visible: true
      }));
      nodes.length = 0;
      nodes.push(...newNodes);
      edges.length = 0;
      edges.push(...result.project_map.edges);
      initLayout();
      draw();
    }
  } catch (err) {
    console.error('Failed to refresh:', err);
  }
}

function esc(s) {
  return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ---- Events ----
const DRAG_THRESHOLD = 5; // pixels - minimum movement to count as drag

canvas.addEventListener('mousedown', (e) => {
  const w = screenToWorld(e.clientX, e.clientY);
  const hit = hitTest(w.x, w.y);

  if (hit && e.button === 0) {
    dragging = { 
      type: 'node', 
      node: hit, 
      offX: hit.x - w.x, 
      offY: hit.y - w.y,
      startScreenX: e.clientX,
      startScreenY: e.clientY,
      moved: false
    };
    canvas.classList.add('dragging');
  } else {
    dragging = { type: 'pan', startX: e.clientX, startY: e.clientY, camX: camera.x, camY: camera.y };
    canvas.classList.add('dragging');
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (dragging) {
    if (dragging.type === 'node') {
      const w = screenToWorld(e.clientX, e.clientY);
      dragging.node.x = w.x + dragging.offX;
      dragging.node.y = w.y + dragging.offY;
      
      // Check if moved past threshold
      const dx = Math.abs(e.clientX - dragging.startScreenX);
      const dy = Math.abs(e.clientY - dragging.startScreenY);
      if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
        dragging.moved = true;
      }
    } else {
      const dx = (e.clientX - dragging.startX) / camera.zoom;
      const dy = (e.clientY - dragging.startY) / camera.zoom;
      camera.x = dragging.camX - dx;
      camera.y = dragging.camY - dy;
    }
    draw();
  } else {
    const w = screenToWorld(e.clientX, e.clientY);
    const prev = hoveredNode;
    hoveredNode = hitTest(w.x, w.y);
    if (hoveredNode !== prev) {
      canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
      draw();
    }
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (dragging && dragging.type === 'node' && !dragging.moved) {
    openPanel(dragging.node);
  }
  canvas.classList.remove('dragging');
  dragging = null;
});

// Prevent click from also opening panel (mouseup already handles it)
canvas.addEventListener('click', (e) => {
  // Only handle clicks on empty space (not nodes) - nodes are handled by mouseup
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.1, Math.min(5, camera.zoom * zoomFactor));
  const wx = (e.clientX - W / 2) / camera.zoom + camera.x;
  const wy = (e.clientY - H / 2) / camera.zoom + camera.y;
  camera.zoom = newZoom;
  camera.x = wx - (e.clientX - W / 2) / camera.zoom;
  camera.y = wy - (e.clientY - H / 2) / camera.zoom;
  updateZoomIndicator();
  draw();
}, { passive: false });

searchInput.addEventListener('input', () => {
  searchTerm = searchInput.value.toLowerCase().trim();
  nodes.forEach(n => {
    if (!searchTerm) { n.highlighted = true; n.visible = true; return; }
    const matches = n.filename.toLowerCase().includes(searchTerm) ||
      (n.class_name && n.class_name.toLowerCase().includes(searchTerm)) ||
      (n.description && n.description.toLowerCase().includes(searchTerm)) ||
      (n.path && n.path.toLowerCase().includes(searchTerm));
    n.highlighted = matches;
    n.visible = matches;
  });
  
  const matchingNodes = nodes.filter(n => n.highlighted);
  const count = matchingNodes.length;
  statsEl.textContent = searchTerm ? `${count}/${nodes.length}` : `${nodes.length} scripts · ${edges.length} connections`;
  
  // If there are matching results, center the view on them
  if (searchTerm && matchingNodes.length > 0) {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    matchingNodes.forEach(n => { 
      minX = Math.min(minX, n.x); 
      maxX = Math.max(maxX, n.x); 
      minY = Math.min(minY, n.y); 
      maxY = Math.max(maxY, n.y); 
    });
    camera.x = (minX + maxX) / 2;
    camera.y = (minY + maxY) / 2;
    
    // Adjust zoom if needed to fit all matching nodes
    if (matchingNodes.length === 1) {
      camera.zoom = Math.max(defaultZoom, 1);
    }
    updateZoomIndicator();
  }
  
  draw();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closePanel();
  if (e.key === '/' && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); }
});

// ---- Init ----
window.addEventListener('resize', () => { resize(); draw(); });
resize();
statsEl.textContent = `${nodes.length} scripts · ${edges.length} connections`;

if (nodes.length === 0) {
  ctx.font = '18px -apple-system, system-ui, sans-serif';
  ctx.fillStyle = '#706c66';
  ctx.textAlign = 'center';
  ctx.fillText('No scripts found in project', W / 2, H / 2);
  zoomIndicator.style.display = 'none';
} else {
  initLayout();
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(n => { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); });
  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;
  const spanX = (maxX - minX) + NODE_W * 2;
  const spanY = (maxY - minY) + NODE_H * 2;
  camera.zoom = Math.min(1.5, W / spanX, H / spanY) * 0.85;
  defaultZoom = camera.zoom;  // Store the default zoom level
  updateZoomIndicator();
  draw();
}
</script>
</body>
</html>
