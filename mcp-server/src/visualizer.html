<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Godot Project Map</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  /* Claude-inspired palette */
  --bg-primary: #1a1a1e;
  --bg-secondary: #242428;
  --bg-tertiary: #2e2e33;
  --bg-hover: #35353b;
  --bg-surface: #28282d;
  --border: #3a3a40;
  --border-light: #4a4a52;
  --text-primary: #e8e4df;
  --text-secondary: #a8a49e;
  --text-muted: #706c66;
  --accent: #d4a27f;
  --accent-light: #e4b896;
  --accent-dim: #8b6f55;

  /* GDScript syntax colors */
  --gd-keyword: #cc7832;
  --gd-func-name: #ffc66d;
  --gd-type: #6897bb;
  --gd-string: #6a8759;
  --gd-number: #6897bb;
  --gd-comment: #808080;
  --gd-var: #cc7832;
  --gd-signal: #a6e3a1;
  --gd-export: #bbb529;
  --gd-builtin: #8888c6;

  /* Edge colors */
  --edge-extends: #7aa2f7;
  --edge-preload: #d4a27f;
  --edge-signal: #a6e3a1;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  overflow: hidden;
  height: 100vh;
}

canvas { display: block; cursor: grab; }
canvas.dragging { cursor: grabbing; }

/* Search bar */
#search-bar {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 10px 18px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#search-bar input {
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 14px;
  width: 260px;
  font-family: inherit;
}

#search-bar input::placeholder { color: var(--text-muted); }
#search-bar .stats { color: var(--text-muted); font-size: 12px; white-space: nowrap; }

#search-bar svg { flex-shrink: 0; }

/* Legend */
#legend {
  position: fixed;
  bottom: 16px;
  left: 16px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 18px;
  font-size: 12px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

/* Zoom indicator - positioned bottom-left, offset from legend */
#zoom-indicator {
  position: fixed;
  bottom: 16px;
  left: 150px;
  z-index: 100;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
}

#zoom-indicator:hover { background: var(--bg-hover); border-color: var(--border-light); }
#zoom-indicator.faded { opacity: 0.4; }
#zoom-indicator.faded:hover { opacity: 1; }
#zoom-indicator svg { flex-shrink: 0; }
#zoom-indicator .zoom-text { color: var(--text-secondary); font-weight: 500; min-width: 36px; text-align: center; }

#legend .item { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; color: var(--text-secondary); }
#legend .item:last-child { margin-bottom: 0; }
#legend .line { width: 28px; height: 2px; border-radius: 1px; }

/* Detail panel */
#detail-panel {
  position: fixed;
  top: 0;
  right: -480px;
  width: 460px;
  min-width: 300px;
  max-width: 80vw;
  height: 100vh;
  background: var(--bg-primary);
  border-left: 1px solid var(--border);
  z-index: 200;
  overflow-y: auto;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: -8px 0 32px rgba(0,0,0,0.4);
}

#detail-panel.open { right: 0; }
#detail-panel.resizing { transition: none; }

/* Horizontal resize handle for panel */
#panel-resize-handle {
  position: absolute;
  left: -4px;
  top: 0;
  width: 8px;
  height: 100%;
  cursor: ew-resize;
  z-index: 201;
}
#panel-resize-handle::after {
  content: '';
  position: absolute;
  left: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 50px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0;
  transition: opacity 0.2s;
}
#panel-resize-handle:hover::after,
#detail-panel.resizing #panel-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

#detail-panel::-webkit-scrollbar { width: 6px; }
#detail-panel::-webkit-scrollbar-track { background: transparent; }
#detail-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.panel-header {
  position: sticky;
  top: 0;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 20px 24px;
  z-index: 10;
}

.panel-header h2 {
  font-size: 20px;
  font-weight: 600;
  color: var(--accent-light);
  margin-bottom: 4px;
  padding-right: 40px;
}

.panel-header .path {
  font-size: 12px;
  color: var(--text-muted);
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  word-break: break-all;
}

.close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 30px;
  height: 30px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.close-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

.panel-body { padding: 16px 24px 32px; }

.desc-block {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 16px;
  padding: 10px 14px;
  background: var(--bg-secondary);
  border-radius: 8px;
  border-left: 3px solid var(--accent);
  line-height: 1.5;
}

.meta-row {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.meta-badge {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  color: var(--text-secondary);
}

.meta-badge span { color: var(--accent-light); font-weight: 600; }

/* Sections */
.section {
  margin-bottom: 12px;
}

.section.resizable {
  display: flex;
  flex-direction: column;
}

.section.resizable .item-list {
  max-height: 200px;
  overflow-y: auto;
  flex-shrink: 1;
}

.section-resize-handle {
  position: relative;
  height: 12px;
  cursor: ns-resize;
  z-index: 5;
  margin: 4px 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.section-resize-handle::after {
  content: '';
  width: 40px;
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  opacity: 0.3;
  transition: opacity 0.2s;
}

.section-resize-handle:hover::after,
.section.resizing .section-resize-handle::after {
  opacity: 1;
  background: var(--accent);
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
}

.section-count {
  background: var(--bg-tertiary);
  color: var(--text-muted);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
}

.item-list { list-style: none; }

.item-list li {
  padding: 6px 10px;
  border-radius: 6px;
  margin-bottom: 1px;
  font-size: 13px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 6px;
  line-height: 1.4;
}

.item-list li:hover { background: var(--bg-secondary); }
.item-list li.clickable { cursor: pointer; }
.item-list li.clickable:hover { background: var(--bg-tertiary); }

/* Inline editable items */
.item-list li .item-actions {
  margin-left: auto;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  flex-shrink: 0;
}
.item-list li:hover .item-actions { opacity: 1; }
.item-actions button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  width: 22px;
  height: 22px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.item-actions button:hover { background: var(--bg-hover); color: var(--text-primary); }
.item-actions button.delete:hover { background: #3d2020; color: #f38ba8; }

/* Inline editable spans */
.editable {
  cursor: text;
  padding: 1px 4px;
  margin: -1px -4px;
  border-radius: 3px;
  transition: background 0.15s;
  min-width: 20px;
  display: inline-block;
}
.editable:hover { background: rgba(255,255,255,0.08); }
.editable:focus {
  outline: none;
  background: rgba(255,255,255,0.12);
  box-shadow: 0 0 0 1px var(--accent);
}
.editable[data-placeholder]:empty::before {
  content: attr(data-placeholder);
  color: var(--text-muted);
  opacity: 0.5;
}

/* Usage panel (like Ctrl+F results) */
.usage-panel {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin: 8px 0;
  overflow: hidden;
}
.usage-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(243, 139, 168, 0.15);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  color: #f38ba8;
}
.usage-panel-header .usage-nav {
  display: flex;
  align-items: center;
  gap: 8px;
}
.usage-panel-header .usage-nav button {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}
.usage-panel-header .usage-nav button:hover { background: var(--bg-hover); }
.usage-panel-list {
  max-height: 150px;
  overflow-y: auto;
}
.usage-panel-item {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  font-size: 11px;
  font-family: 'SF Mono', monospace;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
}
.usage-panel-item:last-child { border-bottom: none; }
.usage-panel-item:hover { background: var(--bg-hover); }
.usage-panel-item.active { background: rgba(212, 162, 127, 0.15); }
.usage-panel-item .file { color: var(--text-muted); margin-right: 8px; }
.usage-panel-item .line { color: var(--accent); margin-right: 8px; }
.usage-panel-item .code { color: var(--text-secondary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.usage-panel-actions {
  display: flex;
  gap: 8px;
  padding: 8px 12px;
  background: var(--bg-secondary);
}
.usage-panel-actions button {
  flex: 1;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  border: 1px solid var(--border);
}
.usage-panel-actions .cancel { background: var(--bg-tertiary); color: var(--text-secondary); }
.usage-panel-actions .delete { background: #3d2020; color: #f38ba8; border-color: #f38ba8; }

/* Add item form */
.add-item-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 10px;
  color: var(--text-muted);
  font-size: 12px;
  cursor: pointer;
  border-radius: 6px;
  margin-top: 4px;
}
.add-item-btn:hover { background: var(--bg-secondary); color: var(--text-secondary); }
.add-item-btn svg { opacity: 0.6; }

.add-item-form {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  margin-top: 8px;
}
.add-item-form .form-row {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}
.add-item-form .form-row:last-child { margin-bottom: 0; }
.add-item-form input, .add-item-form select {
  flex: 1;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-family: inherit;
}
.add-item-form input:focus, .add-item-form select:focus {
  outline: none;
  border-color: var(--accent);
}
.add-item-form .form-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
.add-item-form button {
  padding: 6px 14px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
}
.add-item-form button.cancel {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}
.add-item-form button.confirm {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
  font-weight: 600;
}

/* Syntax tokens */
.kw { color: var(--gd-keyword); font-weight: 600; }
.fn { color: var(--gd-func-name); }
.tp { color: var(--gd-type); }
.str { color: var(--gd-string); }
.num { color: var(--gd-number); }
.cmt { color: var(--gd-comment); font-style: italic; }
.sig { color: var(--gd-signal); }
.exp { color: var(--gd-export); }
.param { color: var(--text-secondary); }
.ret { color: var(--text-muted); }

/* Tags */
.tag {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: -apple-system, system-ui, sans-serif;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.tag-export { background: #3d3520; color: var(--gd-export); }
.tag-signal { background: #1e3326; color: var(--gd-signal); }
.tag-lines { background: var(--bg-tertiary); color: var(--text-muted); font-weight: normal; }
.tag-return { background: #1e2a3a; color: var(--gd-type); }

/* Function viewer */
.func-viewer {
  margin-top: 16px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  overflow: hidden;
}

.func-viewer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  color: var(--text-secondary);
}

.func-viewer-header .func-title { color: var(--gd-func-name); font-weight: 600; }

.func-viewer-close {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 14px;
  padding: 2px 6px;
  border-radius: 4px;
}

.func-viewer-close:hover { color: var(--text-primary); background: var(--bg-hover); }

.func-viewer-code {
  position: relative;
  padding: 12px 0;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  font-size: 12px;
  line-height: 1.6;
  overflow: auto;
  tab-size: 4;
}

/* Editable code area */
.code-editor-container {
  position: relative;
  margin: 0 14px;
}

.code-editor-textarea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  tab-size: inherit;
  padding: 0;
  margin: 0;
  border: none;
  background: transparent;
  color: transparent;
  caret-color: var(--text-primary);
  resize: none;
  outline: none;
  overflow: hidden;
  white-space: pre;
}

.code-editor-textarea::selection {
  background: rgba(255, 255, 255, 0.2);
}

.code-editor-highlight {
  white-space: pre;
  pointer-events: none;
}

.code-editor-container:focus-within {
  outline: 1px solid var(--accent);
  outline-offset: 4px;
  border-radius: 4px;
}

.func-viewer-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 14px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text-muted);
}

.func-viewer-footer .status { opacity: 0; transition: opacity 0.2s; }
.func-viewer-footer .status.visible { opacity: 1; }
.func-viewer-footer .save-btn {
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.2s;
}
.func-viewer-footer .save-btn.active { opacity: 1; }
.func-viewer-footer .save-btn.active:hover { background: var(--accent-light); }

.code-line {
  display: flex;
  padding: 0 14px;
  min-height: 20px;
}

.code-line:hover { background: rgba(255,255,255,0.03); }

.line-num {
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
  padding-right: 16px;
  user-select: none;
  flex-shrink: 0;
  font-size: 11px;
}

.line-content {
  white-space: pre;
  flex: 1;
}
</style>
</head>
<body>
<div id="search-bar">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
  <input type="text" id="search" placeholder="Search scripts..." />
  <span class="stats" id="stats"></span>
</div>

<div id="legend">
  <div class="item"><div class="line" style="background:var(--edge-extends)"></div> extends</div>
  <div class="item"><div class="line" style="background:var(--edge-preload)"></div> preload</div>
  <div class="item"><div class="line" style="background:var(--edge-signal);height:0;border-top:2px dotted var(--edge-signal)"></div> signal</div>
</div>

<div id="zoom-indicator" onclick="resetZoom()" title="Click to reset zoom">
  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><path d="M8 11h6"/><path d="M11 8v6"/></svg>
  <span class="zoom-text" id="zoom-text">100%</span>
</div>

<div id="detail-panel">
  <div id="panel-resize-handle"></div>
  <div class="panel-header">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="panel-title"></h2>
    <div class="path" id="panel-path"></div>
  </div>
  <div class="panel-body" id="panel-body"></div>
</div>

<canvas id="canvas"></canvas>

<script>
const PROJECT_DATA = "%%PROJECT_DATA%%";

// ---- State ----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const searchInput = document.getElementById('search');
const statsEl = document.getElementById('stats');
const detailPanel = document.getElementById('detail-panel');
const zoomIndicator = document.getElementById('zoom-indicator');
const zoomText = document.getElementById('zoom-text');

let W, H;
let camera = { x: 0, y: 0, zoom: 1 };
let defaultZoom = 1;
let dragging = null;
let hoveredNode = null;
let selectedNode = null;
let searchTerm = '';

// Update zoom indicator
function updateZoomIndicator() {
  const percent = Math.round(camera.zoom * 100);
  zoomText.textContent = percent + '%';
  
  // Fade when at default zoom (within 1% tolerance)
  const isDefault = Math.abs(camera.zoom - defaultZoom) < 0.01;
  zoomIndicator.classList.toggle('faded', isDefault);
}

// Reset zoom to default
function resetZoom() {
  camera.zoom = defaultZoom;
  
  // Re-center the view
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(n => { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); });
  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;
  
  updateZoomIndicator();
  draw();
}

// ---- Folder colors ----
const FOLDER_COLORS = [
  'var(--accent)', '#7aa2f7', '#a6e3a1', '#f38ba8', '#cba6f7',
  '#f9e2af', '#94e2d5', '#89dceb', '#fab387', '#f5c2e7'
];
const folderColorMap = {};
let folderColorIdx = 0;

function getFolderColor(folder) {
  if (!folderColorMap[folder]) {
    folderColorMap[folder] = FOLDER_COLORS[folderColorIdx % FOLDER_COLORS.length];
    folderColorIdx++;
  }
  return folderColorMap[folder];
}

// ---- Node layout ----
const NODE_W = 200;
const NODE_H = 54;
const nodes = PROJECT_DATA.nodes.map((n, i) => ({
  ...n,
  x: 0, y: 0,
  color: getFolderColor(n.folder),
  highlighted: true,
  visible: true
}));

const edges = PROJECT_DATA.edges;

// Force-directed layout
function initLayout() {
  const count = nodes.length;
  if (count === 0) return;

  const radius = Math.max(200, count * 45);
  nodes.forEach((n, i) => {
    const angle = (i / count) * Math.PI * 2;
    n.x = Math.cos(angle) * radius;
    n.y = Math.sin(angle) * radius;
  });

  const pathIdx = {};
  nodes.forEach((n, i) => pathIdx[n.path] = i);

  const iterations = 300;
  for (let iter = 0; iter < iterations; iter++) {
    const alpha = 1 - iter / iterations;
    const repulsion = 60000;
    const attraction = 0.004;

    for (let i = 0; i < count; i++) {
      for (let j = i + 1; j < count; j++) {
        let dx = nodes[j].x - nodes[i].x;
        let dy = nodes[j].y - nodes[i].y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 1;
        let force = repulsion / (dist * dist);
        let fx = (dx / dist) * force * alpha;
        let fy = (dy / dist) * force * alpha;
        nodes[i].x -= fx; nodes[i].y -= fy;
        nodes[j].x += fx; nodes[j].y += fy;
      }
    }

    for (const e of edges) {
      const si = pathIdx[e.from], ti = pathIdx[e.to];
      if (si === undefined || ti === undefined) continue;
      let dx = nodes[ti].x - nodes[si].x;
      let dy = nodes[ti].y - nodes[si].y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = dist * attraction * alpha;
      let fx = (dx / dist) * force, fy = (dy / dist) * force;
      nodes[si].x += fx; nodes[si].y += fy;
      nodes[ti].x -= fx; nodes[ti].y -= fy;
    }

    let cx = 0, cy = 0;
    nodes.forEach(n => { cx += n.x; cy += n.y; });
    cx /= count; cy /= count;
    nodes.forEach(n => { n.x -= cx * 0.01; n.y -= cy * 0.01; });
  }
}

// ---- Rendering ----
function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * devicePixelRatio;
  canvas.height = H * devicePixelRatio;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

function screenToWorld(sx, sy) {
  return { x: (sx - W / 2) / camera.zoom + camera.x, y: (sy - H / 2) / camera.zoom + camera.y };
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  const pathIdx = {};
  nodes.forEach((n, i) => pathIdx[n.path] = i);

  // Group edges by node pair, type, and direction for bundled drawing
  const edgeGroups = {};
  for (const e of edges) {
    const si = pathIdx[e.from], ti = pathIdx[e.to];
    if (si === undefined || ti === undefined) continue;
    
    // For signal connections, keep direction (A->B is different from B->A)
    // For extends/preload, also keep direction as they're inherently directional
    const key = `${si}-${ti}-${e.type}`;
    if (!edgeGroups[key]) {
      edgeGroups[key] = { from: e.from, to: e.to, type: e.type, edges: [], si, ti };
    }
    edgeGroups[key].edges.push(e);
  }
  
  // Draw bundled edges
  for (const key of Object.keys(edgeGroups)) {
    const group = edgeGroups[key];
    const s = nodes[group.si], t = nodes[group.ti];
    const count = group.edges.length;
    
    // Skip edges where both nodes are hidden during search
    if (searchTerm && s.visible === false && t.visible === false) continue;

    // Dim edges when one node is hidden, or when neither is highlighted
    const bothVisible = s.visible !== false && t.visible !== false;
    ctx.globalAlpha = (!bothVisible || (!s.highlighted && !t.highlighted)) ? 0.08 : 0.5;
    
    // Calculate perpendicular offset for multiple edge types between same nodes
    const angle = Math.atan2(t.y - s.y, t.x - s.x);
    const perpAngle = angle + Math.PI / 2;
    
    // Get offset based on edge type (so different types don't overlap)
    const typeOffset = group.type === 'extends' ? 0 : group.type === 'preload' ? 8 : 16;
    const offsetX = Math.cos(perpAngle) * typeOffset / camera.zoom;
    const offsetY = Math.sin(perpAngle) * typeOffset / camera.zoom;
    
    ctx.beginPath();
    ctx.moveTo(s.x + offsetX, s.y + offsetY);
    ctx.lineTo(t.x + offsetX, t.y + offsetY);

    if (group.type === 'extends') {
      ctx.strokeStyle = '#7aa2f7'; ctx.setLineDash([]); ctx.lineWidth = 2 / camera.zoom;
    } else if (group.type === 'preload') {
      ctx.strokeStyle = '#d4a27f'; ctx.setLineDash([]); ctx.lineWidth = 1.5 / camera.zoom;
    } else {
      ctx.strokeStyle = '#a6e3a1';
      ctx.setLineDash([4 / camera.zoom, 4 / camera.zoom]);
      ctx.lineWidth = 1.5 / camera.zoom;
    }
    ctx.stroke(); ctx.setLineDash([]);

    // Arrow at midpoint
    const al = 10 / camera.zoom;
    const mx = (s.x + t.x) / 2 + offsetX, my = (s.y + t.y) / 2 + offsetY;
    ctx.beginPath();
    ctx.moveTo(mx + Math.cos(angle) * al, my + Math.sin(angle) * al);
    ctx.lineTo(mx + Math.cos(angle + 2.5) * al * 0.6, my + Math.sin(angle + 2.5) * al * 0.6);
    ctx.lineTo(mx + Math.cos(angle - 2.5) * al * 0.6, my + Math.sin(angle - 2.5) * al * 0.6);
    ctx.closePath(); ctx.fillStyle = ctx.strokeStyle; ctx.fill();
    
    // Draw count badge if multiple connections of same type
    if (count > 1) {
      const badgeX = mx + Math.cos(perpAngle) * (12 / camera.zoom);
      const badgeY = my + Math.sin(perpAngle) * (12 / camera.zoom);
      const badgeSize = 16 / camera.zoom;
      
      ctx.globalAlpha = bothVisible ? 0.9 : 0.3;
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
      
      // Count text
      ctx.fillStyle = '#1a1a1e';
      ctx.font = `bold ${10 / camera.zoom}px -apple-system, system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(count.toString(), badgeX, badgeY);
    }
  }

  ctx.globalAlpha = 1;

  // Draw nodes
  for (const n of nodes) {
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;
    
    const x = n.x - NODE_W / 2, y = n.y - NODE_H / 2;
    const isHovered = n === hoveredNode, isSelected = n === selectedNode;

    ctx.globalAlpha = n.highlighted ? 1 : 0.12;

    // Shadow
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = isHovered ? 16 : 8;
    ctx.shadowOffsetY = 2;

    // Background
    ctx.beginPath(); roundRect(ctx, x, y, NODE_W, NODE_H, 10);
    ctx.fillStyle = isSelected ? '#35353b' : isHovered ? '#303036' : '#242428';
    ctx.fill();

    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

    // Border
    ctx.strokeStyle = isSelected ? n.color : isHovered ? n.color : '#3a3a40';
    ctx.lineWidth = (isSelected ? 2 : 1) / camera.zoom;
    ctx.stroke();

    // Left accent bar
    ctx.beginPath();
    ctx.roundRect(x + 4, y + 8, 3, NODE_H - 16, 2);
    ctx.fillStyle = n.color;
    ctx.fill();

    // Title - scales with zoom
    const fs = 14;
    ctx.font = `600 ${fs}px -apple-system, system-ui, sans-serif`;
    ctx.fillStyle = '#e8e4df';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    const displayName = n.class_name || n.filename.replace('.gd', '');
    ctx.fillText(displayName, x + 16, y + NODE_H / 2 - fs * 0.45);

    // Subtitle with colored stats - scales with zoom
    const ss = 10.5;
    const varCount = n.variables ? n.variables.length : 0;
    const funcCount = n.functions ? n.functions.length : 0;
    const sigCount = n.signals ? n.signals.length : 0;
    
    // Draw subtitle parts with colors
    ctx.font = `${ss}px -apple-system, system-ui, sans-serif`;
    const subY = y + NODE_H / 2 + fs * 0.65;
    let subX = x + 16;
    
    // Extends
    ctx.fillStyle = '#706c66';
    const extendsText = (n.extends || 'Node') + ' · ';
    ctx.fillText(extendsText, subX, subY);
    subX += ctx.measureText(extendsText).width;
    
    // Functions (cyan/teal)
    ctx.fillStyle = '#89dceb';
    ctx.fillText(funcCount + 'f', subX, subY);
    subX += ctx.measureText(funcCount + 'f').width;
    
    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;
    
    // Variables (purple)
    ctx.fillStyle = '#cba6f7';
    ctx.fillText(varCount + 'v', subX, subY);
    subX += ctx.measureText(varCount + 'v').width;
    
    // Space
    ctx.fillStyle = '#706c66';
    ctx.fillText(' ', subX, subY);
    subX += ctx.measureText(' ').width;
    
    // Signals (green)
    ctx.fillStyle = '#a6e3a1';
    ctx.fillText(sigCount + 's', subX, subY);
    subX += ctx.measureText(sigCount + 's').width;
    
    // Separator
    ctx.fillStyle = '#706c66';
    ctx.fillText(' · ', subX, subY);
    subX += ctx.measureText(' · ').width;
    
    // Lines (yellow/amber)
    ctx.fillStyle = '#f9e2af';
    ctx.fillText(n.line_count + 'L', subX, subY);
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
}

function hitTest(wx, wy) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    // Skip hidden nodes during search
    if (searchTerm && n.visible === false) continue;
    if (wx >= n.x - NODE_W / 2 && wx <= n.x + NODE_W / 2 &&
        wy >= n.y - NODE_H / 2 && wy <= n.y + NODE_H / 2) return n;
  }
  return null;
}

// ---- GDScript Syntax Highlighting (Godot 4 colors) ----
// Using a tokenizer approach to avoid regex conflicts
const GD_KEYWORDS = new Set([
  'var', 'func', 'signal', 'class_name', 'extends', 'class', 'enum', 'const',
  'if', 'elif', 'else', 'for', 'while', 'match', 'break', 'continue', 'pass', 'return',
  'and', 'or', 'not', 'in', 'is', 'as', 'self', 'super', 'true', 'false', 'null',
  'void', 'await', 'yield', 'static', 'preload', 'load'
]);

const GD_TYPES = new Set([
  'int', 'float', 'bool', 'String', 'Vector2', 'Vector3', 'Vector4', 
  'Color', 'Array', 'Dictionary', 'Object', 'Node', 'Node2D', 'Node3D',
  'Control', 'Resource', 'Variant', 'void'
]);

function highlightGDScript(code) {
  const tokens = [];
  let i = 0;
  
  while (i < code.length) {
    const ch = code[i];
    const rest = code.slice(i);
    
    // Comments
    if (ch === '#') {
      const end = code.indexOf('\n', i);
      const comment = end === -1 ? code.slice(i) : code.slice(i, end);
      tokens.push({ type: 'comment', text: comment });
      i += comment.length;
      continue;
    }
    
    // Strings
    if (ch === '"' || ch === "'") {
      let j = i + 1;
      while (j < code.length && code[j] !== ch) {
        if (code[j] === '\\') j++; // skip escaped char
        j++;
      }
      const str = code.slice(i, j + 1);
      tokens.push({ type: 'string', text: str });
      i = j + 1;
      continue;
    }
    
    // Annotations (@export, @onready, etc.)
    if (ch === '@') {
      const match = rest.match(/^@\w+/);
      if (match) {
        tokens.push({ type: 'annotation', text: match[0] });
        i += match[0].length;
        continue;
      }
    }
    
    // Arrow ->
    if (rest.startsWith('->')) {
      tokens.push({ type: 'arrow', text: '->' });
      i += 2;
      continue;
    }
    
    // Numbers
    if (/\d/.test(ch)) {
      const match = rest.match(/^\d+\.?\d*/);
      if (match) {
        tokens.push({ type: 'number', text: match[0] });
        i += match[0].length;
        continue;
      }
    }
    
    // Words (identifiers, keywords, types, function calls)
    if (/[a-zA-Z_]/.test(ch)) {
      const match = rest.match(/^[a-zA-Z_]\w*/);
      if (match) {
        const word = match[0];
        const afterWord = code.slice(i + word.length);
        const isCallable = /^\s*\(/.test(afterWord);  // followed by (
        
        let type = 'identifier';  // default: white for variables
        if (GD_KEYWORDS.has(word)) type = 'keyword';
        else if (GD_TYPES.has(word) || /^[A-Z]/.test(word)) type = 'type';
        else if (isCallable) type = 'function';  // function/method calls
        
        tokens.push({ type, text: word });
        i += word.length;
        continue;
      }
    }
    
    // Everything else (operators, punctuation, whitespace)
    tokens.push({ type: 'plain', text: ch });
    i++;
  }
  
  // Convert tokens to HTML with Godot-like colors
  return tokens.map(t => {
    const escaped = t.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    switch (t.type) {
      case 'keyword':    return `<span style="color:#FF7085">${escaped}</span>`;      // Pink/red
      case 'type':       return `<span style="color:#8EFFDA">${escaped}</span>`;      // Teal/mint  
      case 'function':   return `<span style="color:#66E6FF">${escaped}</span>`;      // Cyan (function calls)
      case 'string':     return `<span style="color:#FFE566">${escaped}</span>`;      // Yellow
      case 'number':     return `<span style="color:#A3FFB4">${escaped}</span>`;      // Green
      case 'comment':    return `<span style="color:#9A9EA6">${escaped}</span>`;      // Gray
      case 'annotation': return `<span style="color:#FFB373">${escaped}</span>`;      // Orange
      case 'arrow':      return `<span style="color:#ABC8FF">${escaped}</span>`;      // Light blue
      case 'identifier': return `<span style="color:#CDCFD2">${escaped}</span>`;      // White/light gray (variables)
      default:           return escaped;
    }
  }).join('');
}

// ---- Detail Panel ----
function openPanel(node) {
  selectedNode = node;

  document.getElementById('panel-title').textContent = node.class_name || node.filename.replace('.gd', '');
  document.getElementById('panel-path').textContent = node.path;

  let html = '';

  // Description
  if (node.description) {
    html += `<div class="desc-block">${esc(node.description)}</div>`;
  }

  // Meta badges
  html += `<div class="meta-row">`;
  html += `<div class="meta-badge"><span>${node.line_count}</span> lines</div>`;
  html += `<div class="meta-badge">extends <span>${node.extends || 'Node'}</span></div>`;
  if (node.class_name) html += `<div class="meta-badge">class <span>${esc(node.class_name)}</span></div>`;
  html += `</div>`;

  // Variables - split into @export and regular
  const exportVars = (node.variables || []).filter(v => v.exported);
  const regularVars = (node.variables || []).filter(v => !v.exported);

  // Exports section (always show for adding)
  html += `<div class="section resizable">`;
  html += `<div class="section-header">Exports <span class="section-count">${exportVars.length}</span></div>`;
  html += `<ul class="item-list" id="exports-list">`;
  for (let vi = 0; vi < exportVars.length; vi++) {
    const v = exportVars[vi];
    html += `<li data-var-index="${vi}" data-exported="true">`;
    html += `<span class="exp">@export</span> `;
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, true, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
    html += `<div id="usage-panel-export-${vi}" class="usage-panel" style="display:none"></div>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(true)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add export</div>`;
  html += `<div class="section-resize-handle"></div></div>`;

  // Variables section (always show for adding)
  html += `<div class="section resizable">`;
  html += `<div class="section-header">Variables <span class="section-count">${regularVars.length}</span></div>`;
  html += `<ul class="item-list" id="vars-list">`;
  for (let vi = 0; vi < regularVars.length; vi++) {
    const v = regularVars[vi];
    html += `<li data-var-index="${vi}" data-exported="false">`;
    html += `<span class="kw">var</span> `;
    html += `<span class="editable var-name" contenteditable="true" data-field="name" data-original="${esc(v.name)}">${esc(v.name)}</span>`;
    html += `<span class="ret">:</span> `;
    html += `<span class="tp editable var-type" contenteditable="true" data-field="type" data-placeholder="Type" data-original="${esc(v.type || '')}">${esc(v.type || '')}</span>`;
    html += ` <span class="ret">=</span> `;
    html += `<span class="num editable var-default" contenteditable="true" data-field="default" data-placeholder="value" data-original="${esc(v.default || '')}">${esc(v.default || '')}</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${vi}, false, 'variable')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
    html += `<div id="usage-panel-var-${vi}" class="usage-panel" style="display:none"></div>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewVariable(false)">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add variable</div>`;
  html += `<div class="section-resize-handle"></div></div>`;

  // Functions
  if ((node.functions || []).length > 0) {
    html += `<div class="section resizable" style="max-height:400px">`;
    html += `<div class="section-header">Functions <span class="section-count">${node.functions.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (let fi = 0; fi < node.functions.length; fi++) {
      const f = node.functions[fi];
      html += `<li class="clickable" onclick="toggleFunc(${fi})">`;
      html += `<span class="kw">func</span> <span class="fn">${esc(f.name)}</span>`;
      html += `<span class="param">(${esc(f.params)})</span>`;
      if (f.return_type) html += ` <span class="ret">&rarr;</span> <span class="tp">${esc(f.return_type)}</span>`;
      html += `<span style="margin-left:auto;display:flex;gap:4px">`;
      if (f.body_lines) html += `<span class="tag tag-lines">${f.body_lines}L</span>`;
      html += `</span>`;
      html += `</li>`;
      html += `<div id="func-viewer-${fi}" class="func-viewer" style="display:none"></div>`;
    }
    html += `</ul><div class="section-resize-handle"></div></div>`;
  }

  // Signals section (always show for adding)
  const signalsList = node.signals || [];
  html += `<div class="section">`;
  html += `<div class="section-header">Signals <span class="section-count">${signalsList.length}</span></div>`;
  html += `<ul class="item-list" id="signals-list">`;
  for (let si = 0; si < signalsList.length; si++) {
    const s = signalsList[si];
    const sigName = typeof s === 'string' ? s : s.name;
    const sigParams = typeof s === 'object' ? s.params : '';
    html += `<li data-signal-index="${si}">`;
    html += `<span class="kw">signal</span> `;
    html += `<span class="sig editable signal-name" contenteditable="true" data-field="name" data-original="${esc(sigName)}">${esc(sigName)}</span>`;
    html += `<span class="param">(</span>`;
    html += `<span class="editable signal-params" contenteditable="true" data-field="params" data-placeholder="params" data-original="${esc(sigParams)}">${esc(sigParams)}</span>`;
    html += `<span class="param">)</span>`;
    html += `<span class="item-actions">`;
    html += `<button class="delete" onclick="showDeleteUsages(${si}, false, 'signal')" title="Delete">×</button>`;
    html += `</span>`;
    html += `</li>`;
    html += `<div id="usage-panel-signal-${si}" class="usage-panel" style="display:none"></div>`;
  }
  html += `</ul>`;
  html += `<div class="add-item-btn" onclick="addNewSignal()">`;
  html += `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>`;
  html += `Add signal</div>`;
  html += `</div>`;

  // Connections - group by target and show signal names
  const related = edges.filter(e => e.from === node.path || e.to === node.path);
  if (related.length > 0) {
    // Group connections by target and type
    const connGroups = {};
    for (const e of related) {
      const other = e.from === node.path ? e.to : e.from;
      const dir = e.from === node.path ? 'out' : 'in';
      const key = `${other}-${e.type}-${dir}`;
      if (!connGroups[key]) {
        connGroups[key] = { other, type: e.type, dir, signals: [] };
      }
      if (e.signal_name) connGroups[key].signals.push(e.signal_name);
    }
    
    html += `<div class="section">`;
    html += `<div class="section-header">Connections <span class="section-count">${related.length}</span></div>`;
    html += `<ul class="item-list">`;
    
    for (const key of Object.keys(connGroups)) {
      const g = connGroups[key];
      const dirIcon = g.dir === 'out' ? '→' : '←';
      const color = g.type === 'extends' ? 'var(--edge-extends)' : g.type === 'preload' ? 'var(--edge-preload)' : 'var(--edge-signal)';
      const filename = g.other.split('/').pop();
      
      html += `<li style="flex-wrap:wrap">`;
      html += `${dirIcon} <span style="color:${color}">${esc(filename)}</span> <span class="ret">(${g.type})</span>`;
      
      // Show signal names if this is a signal connection
      if (g.type === 'signal' && g.signals.length > 0) {
        const uniqueSignals = [...new Set(g.signals)];
        html += `<div style="width:100%;margin-top:4px;padding-left:20px;font-size:11px;color:var(--text-muted)">`;
        html += uniqueSignals.map(s => `<span class="sig">${esc(s)}</span>`).join(', ');
        html += `</div>`;
      }
      html += `</li>`;
    }
    html += `</ul></div>`;
  }

  // Preloads
  if ((node.preloads || []).length > 0) {
    html += `<div class="section">`;
    html += `<div class="section-header">Preloads <span class="section-count">${node.preloads.length}</span></div>`;
    html += `<ul class="item-list">`;
    for (const p of node.preloads) {
      html += `<li><span class="str">"${esc(p)}"</span></li>`;
    }
    html += `</ul></div>`;
  }

  document.getElementById('panel-body').innerHTML = html;
  detailPanel.classList.add('open');
  initSectionResizing();
  initInlineEditing();
  draw();
}

// Toggle function body viewer with inline editing
window.toggleFunc = function(fi) {
  const viewer = document.getElementById(`func-viewer-${fi}`);
  if (!viewer) return;

  if (viewer.style.display !== 'none') {
    viewer.style.display = 'none';
    viewer.innerHTML = '';
    return;
  }

  const f = selectedNode.functions[fi];
  if (!f.body) return;

  const editorId = `code-editor-${fi}`;
  
  viewer.innerHTML = `
    <div class="func-viewer-header">
      <span><span class="func-title">${esc(f.name)}</span> · <span id="line-count-${fi}">${f.body.split('\n').length}</span> lines</span>
      <button class="func-viewer-close" onclick="toggleFunc(${fi})">&times;</button>
    </div>
    <div class="func-viewer-code">
      <div class="code-editor-container" id="${editorId}">
        <div class="code-editor-highlight" id="highlight-${fi}"></div>
        <textarea class="code-editor-textarea" id="textarea-${fi}" spellcheck="false"></textarea>
      </div>
    </div>
    <div class="func-viewer-footer">
      <span class="status" id="status-${fi}">Modified</span>
      <span style="display:flex;gap:8px;align-items:center">
        <span style="opacity:0.6">Ctrl+S to save</span>
        <button class="save-btn" id="save-btn-${fi}" onclick="saveFunction(${fi})">Save</button>
      </span>
    </div>
  `;
  
  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);
  const lineCountEl = document.getElementById(`line-count-${fi}`);
  
  // Store original code for comparison
  textarea.dataset.original = f.body;
  textarea.dataset.funcIndex = fi;
  textarea.dataset.scriptPath = selectedNode.path;
  textarea.dataset.funcName = f.name;
  textarea.value = f.body;
  
  // Initial highlight
  updateHighlight(fi);
  
  // Sync highlight on input
  textarea.addEventListener('input', () => {
    updateHighlight(fi);
    const modified = textarea.value !== textarea.dataset.original;
    statusEl.classList.toggle('visible', modified);
    saveBtn.classList.toggle('active', modified);
    lineCountEl.textContent = textarea.value.split('\n').length;
  });
  
  // Sync scroll
  textarea.addEventListener('scroll', () => {
    highlight.style.transform = `translate(-${textarea.scrollLeft}px, -${textarea.scrollTop}px)`;
  });
  
  // Handle tab key
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      textarea.value = textarea.value.substring(0, start) + '\t' + textarea.value.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + 1;
      textarea.dispatchEvent(new Event('input'));
    }
    // Ctrl+S to save
    if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      saveFunction(fi);
    }
  });
  
  // Auto-resize textarea height
  function autoResize() {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
    highlight.style.height = textarea.scrollHeight + 'px';
  }
  textarea.addEventListener('input', autoResize);
  setTimeout(autoResize, 0);
  
  viewer.style.display = 'block';
};

// Update syntax highlighting
function updateHighlight(fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const highlight = document.getElementById(`highlight-${fi}`);
  if (!textarea || !highlight) return;
  
  // Highlight each line
  const lines = textarea.value.split('\n');
  highlight.innerHTML = lines.map(line => highlightGDScript(line)).join('\n');
}

// Save function changes back to Godot
async function saveFunction(fi) {
  const textarea = document.getElementById(`textarea-${fi}`);
  const statusEl = document.getElementById(`status-${fi}`);
  const saveBtn = document.getElementById(`save-btn-${fi}`);
  
  if (!textarea || textarea.value === textarea.dataset.original) return;
  
  const scriptPath = textarea.dataset.scriptPath;
  const funcName = textarea.dataset.funcName;
  const newCode = textarea.value;
  
  statusEl.textContent = 'Saving...';
  statusEl.classList.add('visible');
  
  try {
    // TODO: Send to Godot via MCP
    // For now, just update local state
    const funcIndex = parseInt(textarea.dataset.funcIndex);
    selectedNode.functions[funcIndex].body = newCode;
    selectedNode.functions[funcIndex].body_lines = newCode.split('\n').length;
    
    textarea.dataset.original = newCode;
    statusEl.textContent = 'Saved!';
    saveBtn.classList.remove('active');
    
    setTimeout(() => {
      statusEl.classList.remove('visible');
    }, 2000);
    
    console.log(`[TODO] Save function "${funcName}" in ${scriptPath}`);
  } catch (err) {
    statusEl.textContent = 'Error saving!';
    console.error('Failed to save:', err);
  }
}

function closePanel() {
  selectedNode = null;
  detailPanel.classList.remove('open');
  draw();
}

// ---- Inline Editing for Variables/Signals ----
function initInlineEditing() {
  // Handle blur on editable fields - save changes
  document.querySelectorAll('.editable').forEach(el => {
    el.addEventListener('blur', handleInlineEdit);
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        el.blur();
      }
      if (e.key === 'Escape') {
        el.textContent = el.dataset.original || '';
        el.blur();
      }
    });
  });
}

function handleInlineEdit(e) {
  const el = e.target;
  const li = el.closest('li');
  if (!li) return;
  
  const newValue = el.textContent.trim();
  const original = el.dataset.original || '';
  const field = el.dataset.field;
  
  if (newValue === original) return; // No change
  
  // Determine what type of item this is
  const isSignal = li.dataset.signalIndex !== undefined;
  const isExport = li.dataset.exported === 'true';
  const index = parseInt(isSignal ? li.dataset.signalIndex : li.dataset.varIndex);
  
  if (isSignal) {
    // Update signal
    const sig = selectedNode.signals[index];
    if (typeof sig === 'string') {
      selectedNode.signals[index] = { name: sig, params: '' };
    }
    if (field === 'name') selectedNode.signals[index].name = newValue;
    if (field === 'params') selectedNode.signals[index].params = newValue;
    console.log(`[TODO] Update signal in ${selectedNode.path}:`, selectedNode.signals[index]);
  } else {
    // Update variable
    const vars = selectedNode.variables.filter(v => v.exported === isExport);
    const v = vars[index];
    const actualIndex = selectedNode.variables.findIndex(vr => vr.name === v.name);
    if (actualIndex !== -1) {
      if (field === 'name') selectedNode.variables[actualIndex].name = newValue;
      if (field === 'type') selectedNode.variables[actualIndex].type = newValue;
      if (field === 'default') selectedNode.variables[actualIndex].default = newValue;
      console.log(`[TODO] Update variable in ${selectedNode.path}:`, selectedNode.variables[actualIndex]);
    }
  }
  
  // Update the original value
  el.dataset.original = newValue;
}

// ---- Add New Items ----
function addNewVariable(isExport) {
  const newVar = { name: 'new_var', type: '', default: '', exported: isExport };
  selectedNode.variables.push(newVar);
  openPanel(selectedNode);
  
  // Focus the new variable name after panel refresh
  setTimeout(() => {
    const list = document.getElementById(isExport ? 'exports-list' : 'vars-list');
    const lastItem = list?.querySelector('li:last-of-type .var-name');
    if (lastItem) {
      lastItem.focus();
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(lastItem);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }, 50);
}

function addNewSignal() {
  if (!selectedNode.signals) selectedNode.signals = [];
  selectedNode.signals.push({ name: 'new_signal', params: '' });
  openPanel(selectedNode);
  
  setTimeout(() => {
    const list = document.getElementById('signals-list');
    const lastItem = list?.querySelector('li:last-of-type .signal-name');
    if (lastItem) {
      lastItem.focus();
      const range = document.createRange();
      range.selectNodeContents(lastItem);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }, 50);
}

// ---- Delete with Usage Panel ----
function showDeleteUsages(index, isExport, type) {
  const panelId = type === 'signal' ? `usage-panel-signal-${index}` 
    : isExport ? `usage-panel-export-${index}` : `usage-panel-var-${index}`;
  const panel = document.getElementById(panelId);
  if (!panel) return;
  
  // Get the item name
  let itemName = '';
  if (type === 'signal') {
    const sig = selectedNode.signals[index];
    itemName = typeof sig === 'string' ? sig : sig.name;
  } else {
    const vars = selectedNode.variables.filter(v => v.exported === isExport);
    itemName = vars[index]?.name || '';
  }
  
  // TODO: Actually search for usages across all scripts
  // For now, simulate finding usages
  const mockUsages = findUsages(itemName, type);
  
  if (mockUsages.length === 0) {
    // No usages, can delete directly
    if (type === 'signal') {
      selectedNode.signals.splice(index, 1);
    } else {
      const vars = selectedNode.variables.filter(v => v.exported === isExport);
      const actualIndex = selectedNode.variables.findIndex(v => v.name === vars[index].name);
      if (actualIndex !== -1) selectedNode.variables.splice(actualIndex, 1);
    }
    console.log(`[TODO] Delete ${type} "${itemName}" from ${selectedNode.path}`);
    openPanel(selectedNode);
    return;
  }
  
  // Show usage panel
  panel.innerHTML = `
    <div class="usage-panel-header">
      <span>⚠ "${itemName}" is used in ${mockUsages.length} place${mockUsages.length > 1 ? 's' : ''}</span>
      <div class="usage-nav">
        <span id="usage-counter-${panelId}">1/${mockUsages.length}</span>
        <button onclick="navigateUsage('${panelId}', -1)">‹</button>
        <button onclick="navigateUsage('${panelId}', 1)">›</button>
      </div>
    </div>
    <div class="usage-panel-list">
      ${mockUsages.map((u, i) => `
        <div class="usage-panel-item ${i === 0 ? 'active' : ''}" data-usage-index="${i}" onclick="goToUsage('${u.file}', ${u.line})">
          <span class="file">${u.file.split('/').pop()}</span>
          <span class="line">:${u.line}</span>
          <span class="code">${esc(u.code)}</span>
        </div>
      `).join('')}
    </div>
    <div class="usage-panel-actions">
      <button class="cancel" onclick="hideUsagePanel('${panelId}')">Cancel</button>
      <button class="delete" onclick="forceDelete(${index}, ${isExport}, '${type}', '${itemName}')">Delete Anyway</button>
    </div>
  `;
  panel.style.display = 'block';
  panel.dataset.currentUsage = '0';
}

function hideUsagePanel(panelId) {
  const panel = document.getElementById(panelId);
  if (panel) panel.style.display = 'none';
}

function navigateUsage(panelId, direction) {
  const panel = document.getElementById(panelId);
  if (!panel) return;
  
  const items = panel.querySelectorAll('.usage-panel-item');
  let current = parseInt(panel.dataset.currentUsage || '0');
  current = (current + direction + items.length) % items.length;
  
  items.forEach((item, i) => item.classList.toggle('active', i === current));
  panel.dataset.currentUsage = current.toString();
  document.getElementById(`usage-counter-${panelId}`).textContent = `${current + 1}/${items.length}`;
  
  // Scroll to active item
  items[current].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function goToUsage(file, line) {
  // TODO: Open the file and scroll to line
  console.log(`[TODO] Navigate to ${file}:${line}`);
}

function forceDelete(index, isExport, type, itemName) {
  if (type === 'signal') {
    selectedNode.signals.splice(index, 1);
  } else {
    const vars = selectedNode.variables.filter(v => v.exported === isExport);
    const actualIndex = selectedNode.variables.findIndex(v => v.name === vars[index].name);
    if (actualIndex !== -1) selectedNode.variables.splice(actualIndex, 1);
  }
  console.log(`[TODO] Force delete ${type} "${itemName}" from ${selectedNode.path}`);
  openPanel(selectedNode);
}

// Find usages of a variable/signal across all scripts (mock implementation)
function findUsages(name, type) {
  const usages = [];
  
  // Search in all function bodies of all nodes
  for (const node of nodes) {
    for (const func of (node.functions || [])) {
      if (!func.body) continue;
      const lines = func.body.split('\n');
      lines.forEach((line, i) => {
        // Simple check: does the line contain the name?
        if (line.includes(name)) {
          usages.push({
            file: node.path,
            line: (func.line || 1) + i,
            code: line.trim()
          });
        }
      });
    }
  }
  
  return usages;
}

// Section resizing
let resizingList = null;
let resizeStartY = 0;
let resizeStartHeight = 0;

function initSectionResizing() {
  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    // Remove old listeners
    handle.replaceWith(handle.cloneNode(true));
  });
  
  document.querySelectorAll('.section-resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Find the item-list in this section
      const section = handle.closest('.section');
      resizingList = section?.querySelector('.item-list');
      if (!resizingList) return;
      
      section.classList.add('resizing');
      resizeStartY = e.clientY;
      resizeStartHeight = resizingList.offsetHeight;
      
      document.addEventListener('mousemove', onSectionResize);
      document.addEventListener('mouseup', onSectionResizeEnd);
    });
  });
}

function onSectionResize(e) {
  if (!resizingList) return;
  const dy = e.clientY - resizeStartY;
  const newHeight = Math.max(50, Math.min(500, resizeStartHeight + dy));
  resizingList.style.maxHeight = newHeight + 'px';
}

function onSectionResizeEnd() {
  if (resizingList) {
    const section = resizingList.closest('.section');
    section?.classList.remove('resizing');
    resizingList = null;
  }
  document.removeEventListener('mousemove', onSectionResize);
  document.removeEventListener('mouseup', onSectionResizeEnd);
}

// Panel horizontal resizing
let panelResizing = false;
let panelResizeStartX = 0;
let panelStartWidth = 460;

function initPanelResizing() {
  const handle = document.getElementById('panel-resize-handle');
  const panel = document.getElementById('detail-panel');
  
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    panelResizing = true;
    panel.classList.add('resizing');
    panelResizeStartX = e.clientX;
    panelStartWidth = panel.offsetWidth;
    
    document.addEventListener('mousemove', onPanelResize);
    document.addEventListener('mouseup', onPanelResizeEnd);
  });
}

function onPanelResize(e) {
  if (!panelResizing) return;
  const panel = document.getElementById('detail-panel');
  const dx = panelResizeStartX - e.clientX; // Dragging left = wider
  const newWidth = Math.max(300, Math.min(window.innerWidth * 0.8, panelStartWidth + dx));
  panel.style.width = newWidth + 'px';
  panel.style.right = '0';
}

function onPanelResizeEnd() {
  panelResizing = false;
  const panel = document.getElementById('detail-panel');
  panel.classList.remove('resizing');
  document.removeEventListener('mousemove', onPanelResize);
  document.removeEventListener('mouseup', onPanelResizeEnd);
}

// Initialize panel resizing on load
document.addEventListener('DOMContentLoaded', initPanelResizing);

function esc(s) {
  return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ---- Events ----
const DRAG_THRESHOLD = 5; // pixels - minimum movement to count as drag

canvas.addEventListener('mousedown', (e) => {
  const w = screenToWorld(e.clientX, e.clientY);
  const hit = hitTest(w.x, w.y);

  if (hit && e.button === 0) {
    dragging = { 
      type: 'node', 
      node: hit, 
      offX: hit.x - w.x, 
      offY: hit.y - w.y,
      startScreenX: e.clientX,
      startScreenY: e.clientY,
      moved: false
    };
    canvas.classList.add('dragging');
  } else {
    dragging = { type: 'pan', startX: e.clientX, startY: e.clientY, camX: camera.x, camY: camera.y };
    canvas.classList.add('dragging');
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (dragging) {
    if (dragging.type === 'node') {
      const w = screenToWorld(e.clientX, e.clientY);
      dragging.node.x = w.x + dragging.offX;
      dragging.node.y = w.y + dragging.offY;
      
      // Check if moved past threshold
      const dx = Math.abs(e.clientX - dragging.startScreenX);
      const dy = Math.abs(e.clientY - dragging.startScreenY);
      if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
        dragging.moved = true;
      }
    } else {
      const dx = (e.clientX - dragging.startX) / camera.zoom;
      const dy = (e.clientY - dragging.startY) / camera.zoom;
      camera.x = dragging.camX - dx;
      camera.y = dragging.camY - dy;
    }
    draw();
  } else {
    const w = screenToWorld(e.clientX, e.clientY);
    const prev = hoveredNode;
    hoveredNode = hitTest(w.x, w.y);
    if (hoveredNode !== prev) {
      canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
      draw();
    }
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (dragging && dragging.type === 'node' && !dragging.moved) {
    openPanel(dragging.node);
  }
  canvas.classList.remove('dragging');
  dragging = null;
});

// Prevent click from also opening panel (mouseup already handles it)
canvas.addEventListener('click', (e) => {
  // Only handle clicks on empty space (not nodes) - nodes are handled by mouseup
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.1, Math.min(5, camera.zoom * zoomFactor));
  const wx = (e.clientX - W / 2) / camera.zoom + camera.x;
  const wy = (e.clientY - H / 2) / camera.zoom + camera.y;
  camera.zoom = newZoom;
  camera.x = wx - (e.clientX - W / 2) / camera.zoom;
  camera.y = wy - (e.clientY - H / 2) / camera.zoom;
  updateZoomIndicator();
  draw();
}, { passive: false });

searchInput.addEventListener('input', () => {
  searchTerm = searchInput.value.toLowerCase().trim();
  nodes.forEach(n => {
    if (!searchTerm) { n.highlighted = true; n.visible = true; return; }
    const matches = n.filename.toLowerCase().includes(searchTerm) ||
      (n.class_name && n.class_name.toLowerCase().includes(searchTerm)) ||
      (n.description && n.description.toLowerCase().includes(searchTerm)) ||
      (n.path && n.path.toLowerCase().includes(searchTerm));
    n.highlighted = matches;
    n.visible = matches;
  });
  
  const matchingNodes = nodes.filter(n => n.highlighted);
  const count = matchingNodes.length;
  statsEl.textContent = searchTerm ? `${count}/${nodes.length}` : `${nodes.length} scripts · ${edges.length} connections`;
  
  // If there are matching results, center the view on them
  if (searchTerm && matchingNodes.length > 0) {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    matchingNodes.forEach(n => { 
      minX = Math.min(minX, n.x); 
      maxX = Math.max(maxX, n.x); 
      minY = Math.min(minY, n.y); 
      maxY = Math.max(maxY, n.y); 
    });
    camera.x = (minX + maxX) / 2;
    camera.y = (minY + maxY) / 2;
    
    // Adjust zoom if needed to fit all matching nodes
    if (matchingNodes.length === 1) {
      camera.zoom = Math.max(defaultZoom, 1);
    }
    updateZoomIndicator();
  }
  
  draw();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closePanel();
  if (e.key === '/' && document.activeElement !== searchInput) { e.preventDefault(); searchInput.focus(); }
});

// ---- Init ----
window.addEventListener('resize', () => { resize(); draw(); });
resize();
statsEl.textContent = `${nodes.length} scripts · ${edges.length} connections`;

if (nodes.length === 0) {
  ctx.font = '18px -apple-system, system-ui, sans-serif';
  ctx.fillStyle = '#706c66';
  ctx.textAlign = 'center';
  ctx.fillText('No scripts found in project', W / 2, H / 2);
  zoomIndicator.style.display = 'none';
} else {
  initLayout();
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(n => { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); });
  camera.x = (minX + maxX) / 2;
  camera.y = (minY + maxY) / 2;
  const spanX = (maxX - minX) + NODE_W * 2;
  const spanY = (maxY - minY) + NODE_H * 2;
  camera.zoom = Math.min(1.5, W / spanX, H / spanY) * 0.85;
  defaultZoom = camera.zoom;  // Store the default zoom level
  updateZoomIndicator();
  draw();
}
</script>
</body>
</html>
